<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据库基础6:用户管理DCL</title>
    <url>/uncategorized/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%806-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86DCL/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据库基础5:事</title>
    <url>/uncategorized/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%805-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据库基础4:多表查询</title>
    <url>/uncategorized/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%804-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据库基础3:数据库的备份和还原</title>
    <url>/uncategorized/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%803-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据库基础2:数据库的设计</title>
    <url>/uncategorized/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%802-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据库基础1:约束</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%801-%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>对表中的数据进行<strong>限定</strong>，保证数据的<strong>正确性</strong>、<strong>有效性</strong>和<strong>完整性</strong>。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>主键约束：primary key</li>
<li>非空约束：not null</li>
<li>唯一约束：unique</li>
<li>外键约束：foreign key</li>
</ul>
<h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><p>not null，值不能为 null</p>
<ul>
<li><p>创建表时添加约束。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">	<span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="comment">-- name为非空</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建表完后，添加非空约束。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">MODIFY</span> <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除 name 的非空约束。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">MODIFY</span> <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><p>unique，值不能重复</p>
<ul>
<li><p>创建表时，添加唯一约束。</p>
<ul>
<li><strong>注意</strong> mysql 中，唯一约束限定的列的值可以有多个null<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">    phone_number <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span> <span class="comment">-- 添加唯一约束</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>删除唯一约束。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">DROP</span> <span class="keyword">INDEX</span> phone_number;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在创建表后，添加唯一约束。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">MODIFY</span> phone_number <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><ul>
<li>注意<ul>
<li>含义：非空且唯一。</li>
<li>一张表只能有一个字段为主键。</li>
<li>主键就是表中记录的唯一标识。</li>
</ul>
</li>
<li><p>在创建表时，添加主键约束。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,<span class="comment">-- 给id添加主键约束</span></span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除主键。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 错误 alter table stu modify id int ;</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建完表后，添加主键。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自动增长</strong>：</p>
<ul>
<li>概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长。</li>
<li>在创建表时，添加主键约束，并且完成主键自增长。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,<span class="comment">-- 给id添加主键约束</span></span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>删除自动增长。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">INT</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加自动增长。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>foreign key，让表于表产生关系，从而保证数据的正确性。</p>
<ul>
<li><p>在创建表时，可以添加外键。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">	<span class="comment">--外键列</span></span><br><span class="line">	<span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> <span class="keyword">key</span> (外键列名称) <span class="keyword">references</span> 主表名称(主表列名称)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除外键。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> 外键名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建表之后，添加外键。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (外键字段名称) <span class="keyword">REFERENCES</span> 主表名称(主表列名称);</span><br></pre></td></tr></table></figure>
</li>
<li><p>级联操作。</p>
<ul>
<li>添加级联操作。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 </span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (外键字段名称) <span class="keyword">REFERENCES</span> 主表名称(主表列名称) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>  ;</span><br></pre></td></tr></table></figure>
<ul>
<li>分类：<ul>
<li>级联更新：ON UPDATE CASCADE </li>
<li>级联删除：ON DELETE CASCADE </li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>7.Spring学习笔记:事务管理</title>
    <url>/Java/Spring/Spring/7-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h2><h3 id="Spring中基于-xml-的声明式事务控制配置步骤"><a href="#Spring中基于-xml-的声明式事务控制配置步骤" class="headerlink" title="Spring中基于 xml 的声明式事务控制配置步骤"></a>Spring中基于 xml 的声明式事务控制配置步骤</h3><p>( 1 ) 配置事务管理器</p>
<p>( 2 ) 配置事务的通知</p>
<ul>
<li>1 ) 导入事务的约束</li>
<li>2 ) 使用 <strong>tx:advice</strong> 标签配置事务通知<ul>
<li>属性：<ul>
<li><strong>id</strong>：给事务通知起一个唯一标识</li>
<li><strong>transaction-manager</strong>：给事务通知提供一个事务管理器引用</li>
</ul>
</li>
</ul>
</li>
<li>3 ) 配置 AOP 中的通用切入点表达式</li>
<li>4 ) 建立事务通知和切入点表达式的对应关系</li>
<li>5 ) 配置事务的属性（在事务的通知 tx : advice标签的内部）<ul>
<li><strong>isolation</strong>：用于指定书屋的隔离级别，默认值为 DEFAULT，表示数据库的默认隔离级别</li>
<li><strong>propagation</strong>：用于指定事务的传播行为。默认值是 REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择 SUPPORTS。</li>
<li><strong>read-only</strong>：用于指定事务是否只读。只有查询方法才能设置为 true。默认值是 false，表示读写。</li>
<li><strong>timeout</strong>：用于指定事务的超时时间，默认值是 -1，表示永不超时。如果指定了数值，以秒为单位。</li>
<li><strong>rollback-for</strong>：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。</li>
<li><strong>no-rollback-for</strong>：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。</li>
</ul>
</li>
</ul>
<p><strong>基于xml配置实例</strong></p>
<ul>
<li><p>bean.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--configure service layer--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置账户的持久层--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"com.itheima.dao.impl.AccountDaoImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">&lt;!-- 配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/eesy"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"HotteMYSQL"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">&lt;!--Declarative transaction management--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--configure transaction advice--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:method</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--configure pointcut expression--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.itheima.service.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>IAccountDao</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Id查询账户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span></span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名称查询账户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span></span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新账户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AccountDaoImpl</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = <span class="keyword">super</span>.getJdbcTemplate().query(<span class="string">"select * from account where id = ?"</span>,<span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId);</span><br><span class="line">        <span class="keyword">return</span> accounts.isEmpty()?<span class="keyword">null</span>:accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = <span class="keyword">super</span>.getJdbcTemplate().query(<span class="string">"select * from account where name = ?"</span>,<span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountName);</span><br><span class="line">        <span class="keyword">if</span>(accounts.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(accounts.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"结果集不唯一"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.getJdbcTemplate().update(<span class="string">"update account set name=?,money=? where id=?"</span>,account.getName(),account.getMoney(),account.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Accont</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Integer id;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> Float money;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> id;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.id = id;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> name;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name = name;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Float <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> money;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(Float money)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.money = money;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Account&#123;"</span> +</span><br><span class="line">                 <span class="string">"id="</span> + id +</span><br><span class="line">                 <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                 <span class="string">", money="</span> + money +</span><br><span class="line">                 <span class="string">'&#125;'</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AccountServiceImpl</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(IAccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAccountById(accountId);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"transfer...."</span>);</span><br><span class="line">        <span class="comment">//2.1根据名称查询转出账户</span></span><br><span class="line">        Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">        <span class="comment">//2.2根据名称查询转入账户</span></span><br><span class="line">        Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">        <span class="comment">//2.3转出账户减钱</span></span><br><span class="line">        source.setMoney(source.getMoney()-money);</span><br><span class="line">        <span class="comment">//2.4转入账户加钱</span></span><br><span class="line">        target.setMoney(target.getMoney()+money);</span><br><span class="line">        <span class="comment">//2.5更新转出账户</span></span><br><span class="line">        accountDao.updateAccount(source);</span><br><span class="line">        </span><br><span class="line">                <span class="keyword">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.6更新转入账户</span></span><br><span class="line">        accountDao.updateAccount(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AccountServiceTest</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:bean.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span>  IAccountService as;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testTransfer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        as.transfer(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="number">100f</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="Spring-中基于注解的声明式事务控制配置步骤"><a href="#Spring-中基于注解的声明式事务控制配置步骤" class="headerlink" title="Spring 中基于注解的声明式事务控制配置步骤"></a>Spring 中基于注解的声明式事务控制配置步骤</h3><ul>
<li>1 ) 配置事务管理器。</li>
<li>2 ) 开启 spring 对注解事务的支持。</li>
<li>3 ) 在需要事务支持的地方使用 @Transactional 注解。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置spring创建容器时要扫描的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.itheima"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置JdbcTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/eesy"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"1234"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring中基于注解 的声明式事务控制配置步骤</span></span><br><span class="line"><span class="comment">        1、配置事务管理器</span></span><br><span class="line"><span class="comment">        2、开启spring对注解事务的支持</span></span><br><span class="line"><span class="comment">        3、在需要事务支持的地方使用@Transactional注解</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启spring对注解事务的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 事务控制应该都是在业务层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="meta">@Transactional</span>(propagation= Propagation.SUPPORTS,readOnly=<span class="keyword">true</span>)<span class="comment">//只读型事务的配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAccountById(accountId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要的是读写型事务配置</span></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation= Propagation.REQUIRED,readOnly=<span class="keyword">false</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"transfer...."</span>);</span><br><span class="line">            <span class="comment">//2.1根据名称查询转出账户</span></span><br><span class="line">            Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">            <span class="comment">//2.2根据名称查询转入账户</span></span><br><span class="line">            Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">            <span class="comment">//2.3转出账户减钱</span></span><br><span class="line">            source.setMoney(source.getMoney()-money);</span><br><span class="line">            <span class="comment">//2.4转入账户加钱</span></span><br><span class="line">            target.setMoney(target.getMoney()+money);</span><br><span class="line">            <span class="comment">//2.5更新转出账户</span></span><br><span class="line">            accountDao.updateAccount(source);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.6更新转入账户</span></span><br><span class="line">            accountDao.updateAccount(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>6.Spring学习笔记:面向切面编程(AOP)</title>
    <url>/Java/Spring/Spring/6-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-AOP/</url>
    <content><![CDATA[<h2 id="1-AOP-面向切面编程-的概念"><a href="#1-AOP-面向切面编程-的概念" class="headerlink" title="1.AOP ( 面向切面编程 ) 的概念"></a>1.AOP ( 面向切面编程 ) 的概念</h2><h3 id="1-1-什么是AOP"><a href="#1-1-什么是AOP" class="headerlink" title="1.1 什么是AOP?"></a>1.1 什么是AOP?</h3><p>在单体架构下的软件开发中，一个大型项目通常是依照功能拆分成各个模块。但是如日志、安全和事务管理此类重要且繁琐的开发却没有必要参与到各个模块中，将这些功能与业务逻辑相关的模块分离就是面向切面编程所要解决的问题</p>
<p>AOP采取的是<strong>横向抽取</strong>机制，取代了传统纵向继承体系重复性代码。</p>
<h3 id="1-2-何为软件的横向和纵向？"><a href="#1-2-何为软件的横向和纵向？" class="headerlink" title="1.2 何为软件的横向和纵向？"></a>1.2 何为软件的横向和纵向？</h3><p>从<strong>纵向结构</strong>来看就是我们软件的各个模块，它所负责的是软件的核心业务（如购商品购买、添加购物车等）；从<strong>横向</strong>来看的话，软件的各个模块之间又有所关联，其中会包含一些公共模块（例如日志、权限等）；这些公共模块可以存在于各个核心业务中，而AOP的处理将两者分离，使开发人员可以专注于核心业务的开发，提高了开发效率。</p>
<h3 id="1-3-AOP-的作用及优势"><a href="#1-3-AOP-的作用及优势" class="headerlink" title="1.3 AOP 的作用及优势"></a>1.3 AOP 的作用及优势</h3><p><strong>作用</strong>： 在程序运行期间，不修改源码<strong>对已有方法进行增强</strong>。<br><strong>优势</strong>：</p>
<ul>
<li>减少重复代码 </li>
<li>提高开发效率 </li>
<li>维护方便</li>
</ul>
<h3 id="1-4-AOP底层原理"><a href="#1-4-AOP底层原理" class="headerlink" title="1.4 AOP底层原理"></a>1.4 AOP底层原理</h3><p>使用<strong>动态代理</strong>实现<br>（1）基于 JDK 的代理</p>
<blockquote>
<p>适用于有接口情况，使用动态代理创建接口实现类代理对象</p>
</blockquote>
<p>（2）基于 CGLIB 动态代理</p>
<blockquote>
<p>适用于没有接口情况，使用动态代理创建类的子类代理对象</p>
</blockquote>
<h2 id="2-Spring-中的-AOP"><a href="#2-Spring-中的-AOP" class="headerlink" title="2.Spring 中的 AOP"></a>2.Spring 中的 AOP</h2><h3 id="2-1-AOP术语"><a href="#2-1-AOP术语" class="headerlink" title="2.1 AOP术语"></a>2.1 AOP术语</h3><ul>
<li><strong>Advice</strong> (通知/增强): 所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。<ul>
<li>前置通知</li>
<li>后置通知</li>
<li>异常通知</li>
<li>最终通知</li>
<li>环绕通知</li>
</ul>
</li>
<li><strong>Joinpoint</strong> (连接点): 所谓连接点是指那些<strong>被拦截到的点</strong>。在 Spring 中，这些点指的是<strong>方法</strong>，因为 Spring 只支持方法类型的连接点。</li>
<li><strong>Pointcut</strong> (切入点): 所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。</li>
<li><strong>Introduction</strong> (引介): 引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方 法或 Field。 Target(目标对象): 代理的目标对象。</li>
<li><strong>Weaving</strong> (织入): 是指把增强应用到目标对象来创建新的代理对象的过程。 Spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。</li>
<li><strong>Proxy</strong>（代理）: 一个类被 AOP 织入增强后，就产生一个结果代理类。 Aspect(切面): 是切入点和通知（引介）的结合。</li>
</ul>
<h3 id="2-2-Spring-中基于-xml-的-AOP-配置步骤"><a href="#2-2-Spring-中基于-xml-的-AOP-配置步骤" class="headerlink" title="2.2 Spring 中基于 xml 的 AOP 配置步骤"></a>2.2 Spring 中基于 xml 的 AOP 配置步骤</h3><ol>
<li>把通知 Bean 也交给 Spring 来管理。</li>
<li>使用 <strong>aop : config</strong> 标签来表明开始 AOP 的设置。</li>
<li>使用 <strong>aop : aspect</strong> 标签配置切面。<ul>
<li><strong>id</strong> 属性：是给切面提供一个唯一标识。</li>
<li><strong>ref</strong> 属性：是指定通知类 Bean 的 id。</li>
</ul>
</li>
<li>在 aop : aspect 标签的内部使用对应标签来配置通知的类型。<ol>
<li><strong>aop : before</strong> 标识前置通知。<ul>
<li><strong>method</strong> 属性：用于指定类中哪个放啊是前置通知。</li>
<li><strong>pointcut</strong> 属性：用于指定切入点表达式，该切入点表达式指的是对业务层中哪些方法增强。</li>
</ul>
</li>
<li>切入点表达式的写法：<ul>
<li>关键字：<strong>execution</strong> ( 表达式 )</li>
<li>表达式：<ul>
<li>标准写法：访问修饰符 + 返回值 + 包名.类名.方法名（参数列表）</li>
<li>举例：public void com.greyson.service.impl.IAccountServiceImpl.saveAccount ( )</li>
</ul>
</li>
<li>全通配写法：<code>* * ..*.*(..)</code><ul>
<li>访问修饰符可以省略。</li>
<li>返回值可以使用通配符，表示任意返回值。</li>
<li>包名可以使用通配符，表示任意包，但是有几级包就需要写几个 <code>*.</code></li>
<li>包名可以使用  <code>..</code> 表示当前包和子包。</li>
<li>类名和方法名都可以使用  <code>*</code> 来实现通配。</li>
<li>参数列表：<ul>
<li>可以直接使写数据类型：<ul>
<li>基本类型直接写名称（如 int ）</li>
<li>引用类型写包名.类名的方式 （如 java.lang.String ）</li>
</ul>
</li>
<li>可以使用通配符表四任意类型，但是必须有参数。</li>
<li>可以使用 <code>..</code> 表示有无参数即可，有参数可以是任意类型。</li>
</ul>
</li>
</ul>
</li>
<li><strong>实际开发中切入点表达式的通常写法</strong>：<ul>
<li>切到业务层类实现下的所有方法：<code>* com.greyson.service.impl.*.*(..)</code></li>
</ul>
</li>
<li>配置切入点表达式（<strong>aop : pointcut</strong>）：<ul>
<li>id属性用于指定表达式的唯一标识，expression属性用于指定表达式内容。</li>
<li>此标签写在 aop : aspect 标签内部只能当前切面使用，在其外部则所有切面可用。</li>
</ul>
</li>
</ul>
</li>
<li>Spring常用通知类型<ul>
<li>前置通知（<strong>aop : before</strong>）：在切入点方法执行之前执行。</li>
<li>后置通知（<strong>aop : after-returning</strong>）：在切入点方法正常执行之后执行，它和异常通知永远只能执行一个。</li>
<li>异常通知（<strong>aop : after-throwing</strong>）：在切入点方法执行产生异常之后执行，它和后置通知永远只能执行一个。</li>
<li>最终通知（<strong>aop : after</strong>）：无论切入点方法是否正常执行它都会在其后面执行。</li>
</ul>
</li>
<li>环绕通知</li>
</ol>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容</span></span><br><span class="line"><span class="comment">              此标签写在aop:aspect标签内部只能当前切面使用。</span></span><br><span class="line"><span class="comment">              它还可以写在aop:aspect外面，此时就变成了所有切面可用</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.itheima.service.impl.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置前置通知：在切入点方法执行之前执行--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforePrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span> &gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"afterReturningPrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"afterThrowingPrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"afterPrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置环绕通知 详细的注释请看Logger类中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"aroundPringLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-实例"><a href="#2-3-实例" class="headerlink" title="2.3 实例"></a>2.3 实例</h3><p>1.引入 Maven 工程</p>
<ul>
<li><p>Pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.greyson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>day03_SpringAOP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>webapp<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--解析切入点表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2.编写业务代码</p>
<ul>
<li><p>IAccountService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟保存账户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟更新账户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除账户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AccountServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了保存"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了更新"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了删除"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Logger</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于记录日志的工具类，它里面提供了公共的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"lOGGER类中的printLog开始记录日志了。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>3.配置Spring</p>
<ul>
<li><p>bean.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置Spring的IOC,把Service对象配置进来--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.greyson.service.impl.AccountServiceImpl"</span>&gt;</span>		  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置Logger类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logger"</span> <span class="attr">class</span>=<span class="string">"com.greyson.utils.Logger"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置通知的类型，并且建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"printLog"</span> <span class="attr">pointcut</span>=</span></span><br><span class="line"><span class="tag">                        "<span class="attr">execution</span>(*<span class="attr">com.greyson.service.impl.</span>*<span class="attr">.</span>*(<span class="attr">..</span>))"&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>4.编写测试类</p>
<ul>
<li><p>TestAOP</p>
<pre><code>/**
 * 测试AOP的配置
 */
public class TestAOP {
    public static void main(String[] args) {
        // 1. 获取容器
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
        // 2. 获取对象
        IAccountService accountService = (IAccountService)applicationContext.getBean(&quot;accountService&quot;);
        // 3. 执行方法
        accountService.saveAccount();
        accountService.updateAccount(1);
        accountService.deleteAccount();
    }
}
</code></pre></li>
</ul>
<h3 id="2-4-Spring-中基于注解的-AOP-配置"><a href="#2-4-Spring-中基于注解的-AOP-配置" class="headerlink" title="2.4 Spring 中基于注解的 AOP 配置"></a>2.4 Spring 中基于注解的 AOP 配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于记录日志的工具类，它里面提供了公共的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"logger"</span>)</span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//表示当前类是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.itheima.service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="meta">@Before</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">beforePrintLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知Logger类中的beforePrintLog方法开始记录日志了。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="meta">@AfterReturning</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">afterReturningPrintLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">afterThrowingPrintLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="meta">@After</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">afterPrintLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"最终通知Logger类中的afterPrintLog方法开始记录日志了。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * 问题：</span></span><br><span class="line"><span class="comment">     *      当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。</span></span><br><span class="line"><span class="comment">     * 分析：</span></span><br><span class="line"><span class="comment">     *      通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，</span></span><br><span class="line"><span class="comment">     *      而我们的代码中没有。</span></span><br><span class="line"><span class="comment">     * 解决：</span></span><br><span class="line"><span class="comment">     *      Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，</span></span><br><span class="line"><span class="comment">     *      此方法就相当于明确调用切入点方法。</span></span><br><span class="line"><span class="comment">     *      该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类</span></span><br><span class="line"><span class="comment">     *      供我们使用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * spring中的环绕通知：</span></span><br><span class="line"><span class="comment">     *      它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundPringLog</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Object[] args = pjp.getArgs();<span class="comment">//得到方法执行所需的参数</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Logger类中的aroundPringLog方法开始记录日志了。。。前置"</span>);</span><br><span class="line"></span><br><span class="line">            rtValue = pjp.proceed(args);<span class="comment">//明确调用业务层方法（切入点方法）</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Logger类中的aroundPringLog方法开始记录日志了。。。后置"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> rtValue;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Logger类中的aroundPringLog方法开始记录日志了。。。异常"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(t);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Logger类中的aroundPringLog方法开始记录日志了。。。最终"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>5.Spring学习笔记:Spring整合Junit</title>
    <url>/Java/Spring/Spring/5-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Spring%E6%95%B4%E5%90%88Junit/</url>
    <content><![CDATA[<p>1.导入 Spring 整合 Junit 的 jar ( 坐标 )<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>2.使用 Junit 提供的一个注解把原有的 main 方法替换了，替换成 Spring 提供的。</p>
<ul>
<li><strong>@Runwith</strong></li>
</ul>
<p>3.告知 Spring 的运行器， Spring 和 ioc 创建是基于 xml 还是注解的，并且说明位置，用到的注解如下</p>
<ul>
<li><strong>@ContextConfiguration</strong><ul>
<li>Locations : 指定 xml 文件的位置，加上 classpath 关键字，表示在类路径下。</li>
<li>classes : 指定注解类所在地位置。</li>
</ul>
</li>
</ul>
<p>4.使用 @Autowired 给测试类中的变量注入数据。<br>5.当使用 spring 5.x 版本的时候，要求 junit 的 jar 必须是 4.12 及以上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = SpringConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountService as = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.执行方法</span></span><br><span class="line">        List&lt;Account&gt; accounts = as.findAllAccount();</span><br><span class="line">        <span class="keyword">for</span>(Account account : accounts)&#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>4.Spring学习笔记:基于注解的IOC</title>
    <url>/Java/Spring/Spring/4-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84IOC/</url>
    <content><![CDATA[<h2 id="Spring-中的新注解"><a href="#Spring-中的新注解" class="headerlink" title="Spring 中的新注解"></a>Spring 中的新注解</h2><ul>
<li><p><strong>@Configuration</strong></p>
<ul>
<li>作用：指定当前类是一个配置类。</li>
<li>细节：当配置类作为 AnnotationConfigurationApplicationContext 对象创建的参数时，该注解可以不写。</li>
</ul>
</li>
<li><p><strong>@ComponentScan</strong></p>
<ul>
<li>作用：用于通过注解指定 Spring 在创建容器时要扫描的包。</li>
<li>属性：<br>value : 它和 basepackages 的作用是一样的，都是用于指定创建容器时要扫描的包。<br>使用此注解就等同于在 xml 中配置了：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.greyson"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>@Bean</strong></p>
<ul>
<li>作用：用于把当前方法的返回值作为 bean 对象放入 Spring 的IOC容器中。</li>
<li>属性：<br>name : 用于指定 bean 的 id，当不写时，默认值为当前方法的名称。</li>
<li>细节：<br>当我们使用注解配置方法时，如果方法有参数，Spring 框架会去容器中查找有没有可用的 bean 对象，<br>查找的方式和 Autowired 注解的作用是一样的。</li>
</ul>
</li>
<li><p><strong>@Import</strong></p>
<ul>
<li>作用：用于导入其他的配置类。</li>
<li>属性：<br>value : 用于指定其他配置类的字节码。<br>当我们使用 Import 的注解之后，有 Import 注解的类就是父配置类，而导入的都是子配置类。</li>
</ul>
</li>
<li><p><strong>@Properties</strong></p>
<ul>
<li>作用：用于指定 properties 文件的位置。</li>
<li>属性：<br>value : 指定文件的名称和路径。<br>关键字：classpath , 表示类路径下。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.coderhuye"</span>)</span><br><span class="line"><span class="meta">@Import</span>(JdbcConfig.class)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"template"</span>)</span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">createTemplate</span><span class="params">(DataSource ds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(ds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DruidDataSource ds = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">            ds.setDriverClassName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">            ds.setUrl(<span class="string">"jdbc:mysql:///test01?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC"</span>);</span><br><span class="line">            ds.setUsername(<span class="string">"root"</span>);</span><br><span class="line">            ds.setPassword(<span class="string">"zjuhuye"</span>);</span><br><span class="line">            <span class="keyword">return</span> ds;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>3.Spring学习笔记:依赖注入</title>
    <url>/Java/Spring/Spring/3-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="能注入的数据"><a href="#能注入的数据" class="headerlink" title="能注入的数据"></a><strong>能注入的数据</strong></h3><ul>
<li>基本类型和 String</li>
<li>其他 bean 类型（在配置文件中或者注解中配置过的 bean）</li>
<li>复杂类型/集合类型</li>
</ul>
<h3 id="IOC-的作用"><a href="#IOC-的作用" class="headerlink" title="IOC 的作用"></a><strong>IOC</strong> 的作用</h3><p><strong>减低程序间的耦合</strong>（即依赖关系）</p>
<p>在当前类需要用到其他类的对象，由 Spring 为我们提供，而我们在配置文件中说明依赖关系的维护，这种方式就称为依赖注入。</p>
<h2 id="2-注入方式"><a href="#2-注入方式" class="headerlink" title="2.注入方式"></a>2.注入方式</h2><p>注入的方式：</p>
<ul>
<li>第一种：使用<strong>构造函数</strong>提供</li>
<li>第二种：使用 <strong>set方法</strong>提供</li>
<li>第三种：使用<strong>注解</strong>提供</li>
</ul>
<h3 id="2-1-操作实例："><a href="#2-1-操作实例：" class="headerlink" title="2.1 操作实例："></a>2.1 操作实例：</h3><ul>
<li><p>接口如下：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟保存账户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>实现类：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"accountDao2"</span>)</span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		accountDao.saveAccount();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span>(<span class="string">"accountDao1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对象创建了111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span>(<span class="string">"accountDao2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IAccountDaoImpl2</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对象创建了222"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-使用构造函数注入"><a href="#2-2-使用构造函数注入" class="headerlink" title="2.2 使用构造函数注入"></a>2.2 使用构造函数注入</h3><p>使用的<strong>标签</strong>：<strong>constructor-arg</strong><br>标签出现的<strong>位置</strong>：bean 标签的内部<br>标签中的<strong>属性</strong>：</p>
<ul>
<li>type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型</li>
<li>index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始<br><strong>name</strong>：用于指定给构造函数中指定名称的参数赋值（<strong>常用</strong>）</li>
<li>=============以上三个用于指定给构造函数中哪个参数赋值===============================</li>
<li><strong>value</strong>：用于提供基本类型和String类型的数据</li>
<li><strong>ref</strong>：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。</li>
</ul>
<p><strong>弊端</strong>：</p>
<ul>
<li>改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"泰斯特"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置一个日期对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"now"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-使用-set-方法注入（常用）"><a href="#2-3-使用-set-方法注入（常用）" class="headerlink" title="2.3 使用 set 方法注入（常用）"></a>2.3 使用 set 方法注入（常用）</h3><p>使用的<strong>标签</strong>：<strong>property</strong><br>出现的<strong>位置</strong>：bean 标签的内部<br>标签的<strong>属性</strong>：</p>
<ul>
<li><strong>name</strong>：用于指定注入时所调用的set方法名称</li>
<li><strong>value</strong>：用于提供基本类型和String类型的数据</li>
<li><strong>ref</strong>：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>创建对象时没有明确的限制，可以直接使用默认构造函数</li>
</ul>
<p><strong>弊端</strong>：</p>
<ul>
<li>如果有某个成员必须有值，则获取对象是有可能set方法没有执行。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService2"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"TEST"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"21"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-复杂类型的注入-集合类型的注入"><a href="#2-4-复杂类型的注入-集合类型的注入" class="headerlink" title="2.4 复杂类型的注入/集合类型的注入"></a>2.4 复杂类型的注入/集合类型的注入</h3><p>用于给 List 结构集合注入的标签：</p>
<ul>
<li>list</li>
<li>array</li>
<li>set</li>
</ul>
<p>用于个 Map 结构集合注入的标签:</p>
<ul>
<li>map </li>
<li>props</li>
</ul>
<p>结构相同，标签可以<strong>互换</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService3"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl3"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myStrs"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mySet"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myMap"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testC"</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testD"</span>&gt;</span>ddd<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myProps"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"testA"</span> <span class="attr">value</span>=<span class="string">"aaa"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"testB"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-使用注解注入"><a href="#2-5-使用注解注入" class="headerlink" title="2.5 使用注解注入"></a>2.5 使用注解注入</h3><h4 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h4><p>第一步：在类或方法的前面加上<strong>注解关键字</strong><br>第二步：<strong>引入约束</strong>，注意此处约束多了 xmlns:context…<br>第三步：<strong>添加配置</strong>，告知 Spring 在创建容器时要扫描的包，配置所需的标签不是在 bean 约束中，而是一个名称为 context 的名称空间和约束中，完整配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.itheima"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="有哪些注解？"><a href="#有哪些注解？" class="headerlink" title="有哪些注解？"></a>有哪些注解？</h4><h5 id="用于创建对象的"><a href="#用于创建对象的" class="headerlink" title="用于创建对象的"></a>用于<strong>创建对象</strong>的</h5><p>作用：等同于 xml 配置文件中编写一个 <bean> 标签</bean></p>
<ul>
<li><strong>@Component</strong><ul>
<li>形式：@Component(value=” “)   /  @Component(“ “)</li>
<li>作用：用于把当前类对象存入 Spring 容器中</li>
<li>属性：<br>value : 用于指定 bean 的 id，当我们不写的时候，它的默认值是当前类名，且首字母改小写;当值只有一个的时候可以省略</li>
</ul>
</li>
</ul>
<p>以下三个注解的作用与 @Component 完全一样，它们是 Spring 提供的更明确的划分，使三层对象更加清晰</p>
<ul>
<li><strong>@Controller</strong>   用于<strong>表现层</strong></li>
<li><strong>@Service</strong>        用于<strong>业务层</strong></li>
<li><strong>@Repository</strong>  用于<strong>持久层</strong></li>
</ul>
<h5 id="用于注入数据的"><a href="#用于注入数据的" class="headerlink" title="用于注入数据的"></a>用于<strong>注入数据</strong>的</h5><p>作用：等同于在 <bean> 标签中写一个 <property> 标签。</property></bean></p>
<ul>
<li><p><strong>@Autowired</strong></p>
<ul>
<li>作用：<strong>自动按照类型注入</strong>，只要容器中有<strong>唯一</strong>的一个 bean 对象类型和要注入的变量类型匹配，就可以注入成功，如果 IOC 容器中没有任何  bean 的类型和要注入的变量类型匹配，则报错。</li>
<li>出现位置：可以是变量上，也可以是方法上。</li>
<li>细节：在使用注解注入时，set 方法就不是必须的了。 </li>
</ul>
</li>
<li><p><strong>@Qualifier</strong>     </p>
<ul>
<li>作用：在按照类型注入的基础上再<strong>按照名称注入</strong>，它<strong>在给类成员注入时不能单独使用(需结合@Autowired)，但是在给方法参数注入时可以</strong>。     </li>
<li>属性：value : 用于指定注入的 bean 的  id</li>
</ul>
</li>
<li><p><strong>@Resource</strong>     </p>
<ul>
<li>作用：直接按照 bean 的 id 注入，可以直接使用。 </li>
<li>属性：name : 用于指定 bean 的 id     </li>
<li>等同于@Autowired+@Qualifier   </li>
</ul>
</li>
</ul>
<p>以上三个注入都<strong>只能注入其他 bean 类型的数据</strong>，而基本类型和 String 类型的数据无法使用上述注解实现。另外，<strong>集合类型的注入只能通过 xml 配置文件实现</strong>。</p>
<ul>
<li><strong>@Value</strong><ul>
<li>作用：用于注入基本类型和 String 类型的数据。</li>
<li>属性：<br>value : 用于指定数据的值，它可以使用 Spring 中 Spel (即spring的el表达式)<br>Spel 的写法：${表达式}</li>
</ul>
</li>
</ul>
<h5 id="用于改变范围的"><a href="#用于改变范围的" class="headerlink" title="用于改变范围的"></a>用于改变范围的</h5><p>作用：等同于在 <bean> 标签中使用 scope 属性。</bean></p>
<ul>
<li><strong>@Scope</strong><ul>
<li>作用：用于指定 bean 的作用范围。</li>
<li>属性：value : 指定范围的取值，常用为 singleton ,  prototype。</li>
</ul>
</li>
</ul>
<h5 id="和生命周期相关（了解）"><a href="#和生命周期相关（了解）" class="headerlink" title="和生命周期相关（了解）"></a>和生命周期相关（了解）</h5><p>作用：等同于在 <bean> 标签中使用 init-method 和 destroy-method。</bean></p>
<ul>
<li><strong>@PreDestory</strong><br>作用：用于指定<strong>销毁方法</strong>  </li>
<li><strong>@Postcontrust</strong><br>  作用：用于指定<strong>初始化方法</strong></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>2.Spring学习笔记:Bean的装配与管理</title>
    <url>/Java/Spring/Spring/2-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Bean%E7%9A%84%E8%A3%85%E9%85%8D%E4%B8%8E%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-Spring-中-Bean-的细节"><a href="#1-Spring-中-Bean-的细节" class="headerlink" title="1.Spring 中 Bean 的细节"></a>1.Spring 中 Bean 的细节</h2><h3 id="三种创建-bean-对象的方式"><a href="#三种创建-bean-对象的方式" class="headerlink" title="三种创建 bean 对象的方式"></a>三种创建 bean 对象的方式</h3><ol>
<li><p>使用<strong>默认构造函数</strong>创建</p>
<p>在 spring 的配置文件中，使用 id 和 class 属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建 bean 对象，此时如果类中没有默认构造函数，则对象无法创建。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"accountService"</span> <span class="attr">class</span> = <span class="string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>普通工厂中的方法</strong>创建对象（使用某个类中的方法创建对象，并存入  Spring 容器），如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *模拟一个工厂类，该类可能存在于jar包中，无法通过修改源码的方式来提供默认构造函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IAccountService <span class="title">getAccountService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置方式如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"instanceFactory"</span> <span class="attr">class</span> = <span class="string">"com.itheima.factory.InstanceFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"accountService"</span> <span class="attr">factory-bean</span>=<span class="string">"instanceFactory"</span> <span class="attr">factory-method</span></span></span><br><span class="line"><span class="tag">          =<span class="string">"getAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>工厂中的静态方法</strong>创建对象（使用某个类中的静态方法创建对象，并存入 Spring 容器），如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> IAccountService <span class="title">getAccountService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置方式如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"accountService"</span> <span class="attr">class</span> = <span class="string">"com.itheima.factory.StaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-bean-的作用范围调整"><a href="#2-bean-的作用范围调整" class="headerlink" title="2.bean 的作用范围调整"></a>2.bean 的作用范围调整</h2><ol>
<li><p>bean 标签的 <strong>scope</strong> 属性<br>作用：用于指定 bean 的<strong>作用范围。</strong><br>取值：常用的就是<strong>单例</strong>和<strong>多例。</strong></p>
<ul>
<li><strong>singleton</strong> : 单例的（<strong>default</strong>）。</li>
<li><strong>prototype</strong> : 多例的。</li>
<li>request : 作用于 web 应用的请求范围。</li>
<li>session : 作用于 web  应用的会话范围。</li>
<li>global-session : 作用于集群的会话范围（全局会话范围），当不是集群范围时，它就是 session。</li>
</ul>
</li>
<li><p>bean 对象的<strong>声明周期</strong><br><strong>单例</strong>对象：</p>
<ul>
<li>出生：当容器创建时发生。</li>
<li>活着：只要容器还在对象就一直活着。</li>
<li>死亡：容器销毁，对象消亡。</li>
</ul>
<p>总结：单例对象的<strong>声明周期和容器相同</strong>。</p>
<p><strong>多例</strong>对象：</p>
<ul>
<li>出生：当我们使用对象时 Spring 框架为我们创建。</li>
<li>活着：对象只要是在使用过程中就活着。</li>
<li>死亡：当对象长时间不用，且没有别的对象引用时，由 Java 的 GC 回收。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>1.Spring学习笔记:入门案例</title>
    <url>/Java/Spring/Spring/1-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h3 id="1-实例"><a href="#1-实例" class="headerlink" title="1.实例"></a>1.实例</h3><ol>
<li>通过 Idea 创建 maven 项目</li>
<li>配置 Spring 配置文件 ApplicationContext.xml</li>
<li>编写接口及实现类</li>
</ol>
<ul>
<li><p>IaccountDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟保存账户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>IaccountService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户业务层的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟保存账户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AccountDaoImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"保存了账户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AccountServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao = <span class="keyword">new</span> AccountDaoImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">saveAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>4.编写测试类 Client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟一个表现层，用于调用业务层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *获取IOC的核心容器，并根据id获取对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">          <span class="comment">// 两种不同的方式获取Bean对象</span></span><br><span class="line">          IAccountService as = (IAccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">          IAccountDao adao = ac.getBean(<span class="string">"accountDao"</span>,IAccountDao.class);</span><br><span class="line">          System.out.println(as);</span><br><span class="line">          System.out.println(adao);</span><br><span class="line">          <span class="comment">// as.saveAccount();</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-知识点"><a href="#2-知识点" class="headerlink" title="2.知识点"></a>2.知识点</h3><ol>
<li><p><strong>ApplicationContext</strong> 的三个常用实现类：</p>
<ul>
<li><p><strong>ClassPathXmlApplicationContext</strong>： 它可以加载<strong>路径下</strong>的配置文件，要求配置文件必须在路径下，否则加载不了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bea</span></span><br><span class="line"><span class="string">ns.xml"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>FileSyetemXmlApplicationContext</strong>：它可以加载<strong>磁盘任意路径下</strong>的配置文件（<strong>必须有访问权限</strong>）。<br>加载方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"C:\\user\\greyson\\..."</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>AnnotationConfigApplicationContext</strong>：它是用于<strong>读取注解创建容器</strong>的</p>
</li>
</ul>
</li>
<li><p>核心容器的两个接口引发出来的问题</p>
<ul>
<li>ApplicationContext：它在创建核心容器时，创建对象采取的策略是采用立即加载的方式，也就是说，只要一读取完配置文件就马上创建配置文件中配置的对象。<ul>
<li><strong>单例对象</strong>适用。</li>
<li>开发中常采用此接口。</li>
</ul>
</li>
<li>BeanFactory: 它在构建核心容器时，创建对象的策略是采用延迟加载的方式，什么时候获取 id 对象了，什么时候就创建对象。<ul>
<li><strong>多例对象</strong>适用。</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲流、转换流、序列化流</title>
    <url>/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%93%E5%86%B2%E6%B5%81%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81/</url>
    <content><![CDATA[<h1 id="1-缓冲流"><a href="#1-缓冲流" class="headerlink" title="1.缓冲流"></a>1.缓冲流</h1><p>能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，是对基本流对象的一种增强。</p>
<h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>缓冲流，也叫高效流，是对4个基本的 <code>FileXxx</code> 流的增强，所以也是 4 个流，按照数据类型分类：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统 IO 次数，从而提高读写的效率。</p>
<h2 id="1-2-字节缓冲流"><a href="#1-2-字节缓冲流" class="headerlink" title="1.2 字节缓冲流"></a>1.2 字节缓冲流</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li>
<li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"bis.txt"</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"bos.txt"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h3><p>查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。</p>
<ol>
<li>基本流，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">        	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"jdk9.exe"</span>);</span><br><span class="line">        	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"copy.exe"</span>)</span><br><span class="line">        )&#123;</span><br><span class="line">        	<span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"普通流复制时间:"</span>+(end - start)+<span class="string">" 毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">十几分钟过去了...</span><br></pre></td></tr></table></figure>
<ol>
<li>缓冲流，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">        	BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"jdk9.exe"</span>));</span><br><span class="line">	     BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"copy.exe"</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">        <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"缓冲流复制时间:"</span>+(end - start)+<span class="string">" 毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">缓冲流复制时间:<span class="number">8016</span> 毫秒</span><br></pre></td></tr></table></figure>
<p>如何更快呢？</p>
<p>使用数组的方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">      	<span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">			BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"jdk9.exe"</span>));</span><br><span class="line">		 BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"copy.exe"</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">          	<span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"缓冲流使用数组复制时间:"</span>+(end - start)+<span class="string">" 毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">缓冲流使用数组复制时间:<span class="number">666</span> 毫秒</span><br></pre></td></tr></table></figure>
<h2 id="1-3-字符缓冲流"><a href="#1-3-字符缓冲流" class="headerlink" title="1.3 字符缓冲流"></a>1.3 字符缓冲流</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li>
<li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"br.txt"</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bw.txt"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p>
<ul>
<li>BufferedReader：<code>public String readLine()</code>：读一行文字。 </li>
<li>BufferedWriter：<code>public void newLine()</code>：写一行行分隔符,由系统属性定义符号。 </li>
</ul>
<p><code>readLine</code>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	 <span class="comment">// 创建流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"in.txt"</span>));</span><br><span class="line">		<span class="comment">// 定义字符串,保存读取的一行文字</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">      	<span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(line);</span><br><span class="line">            System.out.println(<span class="string">"------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>newLine</code>方法演示，代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriterDemo</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">      	<span class="comment">// 创建流对象</span></span><br><span class="line">		BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"out.txt"</span>));</span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">        bw.write(<span class="string">"黑马"</span>);</span><br><span class="line">      	<span class="comment">// 写出换行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">"程序"</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">"员"</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出效果:</span><br><span class="line">黑马</span><br><span class="line">程序</span><br><span class="line">员</span><br></pre></td></tr></table></figure>
<h2 id="1-4-练习-文本排序"><a href="#1-4-练习-文本排序" class="headerlink" title="1.4 练习:文本排序"></a>1.4 练习:文本排序</h2><p>请将文本信息恢复顺序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。</span><br><span class="line">8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。</span><br><span class="line">4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。</span><br><span class="line">2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。</span><br><span class="line">1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。</span><br><span class="line">9.今当远离，临表涕零，不知所言。</span><br><span class="line">6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。</span><br><span class="line">7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。</span><br><span class="line">5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</span><br></pre></td></tr></table></figure>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>逐行读取文本信息。</li>
<li>解析文本信息到集合中。</li>
<li>遍历集合，按顺序，写出文本信息。</li>
</ol>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建map集合,保存文本数据,键为序号,值为文字</span></span><br><span class="line">        HashMap&lt;String, String&gt; lineMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"in.txt"</span>));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"out.txt"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析文本</span></span><br><span class="line">            String[] split = line.split(<span class="string">"\\."</span>);</span><br><span class="line">            <span class="comment">// 保存到集合</span></span><br><span class="line">            lineMap.put(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历map集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lineMap.size(); i++) &#123;</span><br><span class="line">            String key = String.valueOf(i);</span><br><span class="line">            <span class="comment">// 获取map中文本</span></span><br><span class="line">            String value = lineMap.get(key);</span><br><span class="line">          	<span class="comment">// 写出拼接文本</span></span><br><span class="line">            bw.write(key+<span class="string">"."</span>+value);</span><br><span class="line">          	<span class="comment">// 写出换行</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-转换流"><a href="#2-转换流" class="headerlink" title="2.转换流"></a>2.转换流</h1><h2 id="2-1-字符编码和字符集"><a href="#2-1-字符编码和字符集" class="headerlink" title="2.1 字符编码和字符集"></a>2.1 字符编码和字符集</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p>
<p>编码:字符(能看懂的)—字节(看不懂的)</p>
<p>解码:字节(看不懂的)—&gt;字符(能看懂的)</p>
<ul>
<li><p><strong>字符编码 <code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p>
<p>编码表:生活中文字和计算机中二进制的对应规则</p>
</li>
</ul>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul>
<li><strong>字符集 <code>Charset</code></strong>：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>
</ul>
<p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有 ASCII 字符集、GBK 字符集、Unicode 字符集等。</p>
<p><img src="/Java/基础知识/缓冲流、转换流、序列化流/1_charset.jpg" style="zoom:50%;"></p>
<p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p>
<ul>
<li><strong>ASCII字符集</strong> ：<ul>
<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li>
<li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII 的扩展字符集使用 8 位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li>
</ul>
</li>
<li><strong>ISO-8859-1字符集</strong>：<ul>
<li>拉丁码表，别名 Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li>
<li>ISO-8859-1 使用单字节编码，兼容 ASCII 编码。</li>
</ul>
</li>
<li><strong>GBxxx字符集</strong>：<ul>
<li>GB 就是国标的意思，是为了显示中文而设计的一套字符集。</li>
<li><strong>GB2312</strong>：简体中文码表。一个小于 127 的字符的意义与原来相同。但两个大于 127 的字符连在一起时，就表示一个汉字，这样大约可以组合了包含 7000 多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在 127 号以下的那些就叫”半角”字符了。</li>
<li><strong>GBK</strong>：最常用的中文码表。是在 GB2312 标准基础上的扩展规范，使用了双字节编码方案，共收录了 21003 个汉字，完全兼容 GB2312 标准，同时支持繁体汉字以及日韩汉字等。</li>
<li><strong>GB18030</strong>：最新的中文码表。收录汉字 70244 个，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li>
</ul>
</li>
<li><strong>Unicode字符集</strong> ：<ul>
<li>Unicode 编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>
<li>它最多使用 4 个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的 UTF-8 编码。</li>
<li>UTF-8 编码，可以用来表示 Unicode 标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持 UTF-8 编码。所以，我们开发 Web 应用，也要使用 UTF-8 编码。它使用一至四个字节为每个字符编码，编码规则：<ol>
<li>128 个 US-ASCII 字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。 </li>
<li>大部分常用字（含中文），使用三个字节编码。</li>
<li>其他极少使用的 Unicode 辅助字符，使用四字节编码。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-编码引出的问题"><a href="#2-2-编码引出的问题" class="headerlink" title="2.2 编码引出的问题"></a>2.2 编码引出的问题</h2><p>在 IDEA 中，使用<code>FileReader</code> 读取项目中的文本文件。由于 IDEA 的设置，都是默认的 <code>UTF-8</code> 编码，所以没有任何问题。但是，当读取 Windows 系统中创建的文本文件时，由于 Windows 系统的默认是GBK编码，就会出现乱码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">"E:\\File_GBK.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">���</span><br></pre></td></tr></table></figure>
<p>那么如何读取 GBK 编码的文件呢？ </p>
<h2 id="2-3-InputStreamReader类"><a href="#2-3-InputStreamReader类" class="headerlink" title="2.3 InputStreamReader类"></a>2.3 InputStreamReader类</h2><p>转换流 <code>java.io.InputStreamReader</code>，是 Reader 的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p>构造举例，代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"in.txt"</span>));</span><br><span class="line">InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"in.txt"</span>) , <span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="指定编码读取"><a href="#指定编码读取" class="headerlink" title="指定编码读取"></a>指定编码读取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 定义文件路径,文件为gbk编码</span></span><br><span class="line">        String FileName = <span class="string">"E:\\file_gbk.txt"</span>;</span><br><span class="line">      	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName));</span><br><span class="line">      	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName) , <span class="string">"GBK"</span>);</span><br><span class="line">		<span class="comment">// 定义变量,保存字符</span></span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">      	<span class="comment">// 使用默认编码字符流读取,乱码</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read); <span class="comment">// ��Һ�</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 使用指定编码字符流读取,正常解析</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);<span class="comment">// 大家好</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-OutputStreamWriter类"><a href="#2-4-OutputStreamWriter类" class="headerlink" title="2.4 OutputStreamWriter类"></a>2.4 OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是 Writer 的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p>构造举例，代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStreamWriter isr = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.txt"</span>));</span><br><span class="line">OutputStreamWriter isr2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.txt"</span>) , <span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="指定编码写出"><a href="#指定编码写出" class="headerlink" title="指定编码写出"></a>指定编码写出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 定义文件路径</span></span><br><span class="line">        String FileName = <span class="string">"E:\\out.txt"</span>;</span><br><span class="line">      	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName));</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      	osw.write(<span class="string">"你好"</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">        osw.close();</span><br><span class="line">      	</span><br><span class="line">		<span class="comment">// 定义文件路径</span></span><br><span class="line">		String FileName2 = <span class="string">"E:\\out2.txt"</span>;</span><br><span class="line">     	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        OutputStreamWriter osw2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName2),<span class="string">"GBK"</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      	osw2.write(<span class="string">"你好"</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">        osw2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转换流理解图解"><a href="#转换流理解图解" class="headerlink" title="转换流理解图解"></a>转换流理解图解</h3><p><strong>转换流是字节与字符间的桥梁！</strong></p>
<p><img src="/Java/基础知识/缓冲流、转换流、序列化流/2_zhuanhuan.jpg" style="zoom:50%;"></p>
<h2 id="2-5-练习：转换文件编码"><a href="#2-5-练习：转换文件编码" class="headerlink" title="2.5 练习：转换文件编码"></a>2.5 练习：转换文件编码</h2><p>将 GBK 编码的文本文件，转换为 UTF-8 编码的文本文件。</p>
<h3 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>指定 GBK 编码的转换流，读取文本文件。</li>
<li>使用 UTF-8 编码的转换流，写出文本文件。</li>
</ol>
<h3 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      </span><br><span class="line">    	<span class="comment">// 1.定义文件路径</span></span><br><span class="line">     	String srcFile = <span class="string">"file_gbk.txt"</span>;</span><br><span class="line">        String destFile = <span class="string">"file_utf8.txt"</span>;</span><br><span class="line">		<span class="comment">// 2.创建流对象</span></span><br><span class="line">    	<span class="comment">// 2.1 转换输入流,指定GBK编码</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(srcFile) , <span class="string">"GBK"</span>);</span><br><span class="line">    	<span class="comment">// 2.2 转换输出流,默认utf8编码</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(destFile));</span><br><span class="line">		<span class="comment">// 3.读写数据</span></span><br><span class="line">    	<span class="comment">// 3.1 定义数组</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    	<span class="comment">// 3.2 定义长度</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">    	<span class="comment">// 3.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 循环写出</span></span><br><span class="line">          	osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 4.释放资源</span></span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-序列化"><a href="#3-序列化" class="headerlink" title="3.序列化"></a>3.序列化</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化： </p>
<p><img src="/Java/基础知识/缓冲流、转换流、序列化流/3_xuliehua.jpg" style="zoom:50%;"></p>
<h2 id="3-2-ObjectOutputStream类"><a href="#3-2-ObjectOutputStream类" class="headerlink" title="3.2 ObjectOutputStream类"></a>3.2 ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream</code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ObjectOutputStream(OutputStream out)</code>： 创建一个指定 OutputStream 的 ObjectOutputStream。</li>
</ul>
<p>构造举例，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">"employee.txt"</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure>
<h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol>
<li>一个对象要想序列化，必须满足两个条件:</li>
</ol>
<ul>
<li>该类必须实现<code>java.io.Serializable</code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">"Address  check : "</span> + name + <span class="string">" -- "</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.写出对象方法</p>
<ul>
<li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">    	Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">    	e.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    	e.address = <span class="string">"beiqinglu"</span>;</span><br><span class="line">    	e.age = <span class="number">20</span>; </span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">      		<span class="comment">// 创建序列化流对象</span></span><br><span class="line">          ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"employee.txt"</span>));</span><br><span class="line">        	<span class="comment">// 写出对象</span></span><br><span class="line">        	out.writeObject(e);</span><br><span class="line">        	<span class="comment">// 释放资源</span></span><br><span class="line">        	out.close();</span><br><span class="line">        	fileOut.close();</span><br><span class="line">        	System.out.println(<span class="string">"Serialized data is saved"</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException i)   &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Serialized data is saved</span><br></pre></td></tr></table></figure>
<h2 id="3-3-ObjectInputStream类"><a href="#3-3-ObjectInputStream类" class="headerlink" title="3.3 ObjectInputStream类"></a>3.3 ObjectInputStream类</h2><p>ObjectInputStream 反序列化流，将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象。 </p>
<h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ObjectInputStream(InputStream in)</code>： 创建一个指定 InputStream 的 ObjectInputStream。</li>
</ul>
<h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的 class 文件，我们可以进行反序列化操作，调用 <code>ObjectInputStream</code> 读取对象的方法：</p>
<ul>
<li><code>public final Object readObject ()</code> : 读取一个对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;		</span><br><span class="line">             <span class="comment">// 创建反序列化流</span></span><br><span class="line">             FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">"employee.txt"</span>);</span><br><span class="line">             ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">             <span class="comment">// 读取一个对象</span></span><br><span class="line">             e = (Employee) in.readObject();</span><br><span class="line">             <span class="comment">// 释放资源</span></span><br><span class="line">             in.close();</span><br><span class="line">             fileIn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">             <span class="comment">// 捕获其他异常</span></span><br><span class="line">             i.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException c)  &#123;</span><br><span class="line">        	<span class="comment">// 捕获类找不到异常</span></span><br><span class="line">             System.out.println(<span class="string">"Employee class not found"</span>);</span><br><span class="line">             c.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无异常,直接打印输出</span></span><br><span class="line">        System.out.println(<span class="string">"Name: "</span> + e.name);	<span class="comment">// zhangsan</span></span><br><span class="line">        System.out.println(<span class="string">"Address: "</span> + e.address); <span class="comment">// beiqinglu</span></span><br><span class="line">        System.out.println(<span class="string">"age: "</span> + e.age); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的 class 文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p>
<h3 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a><strong>反序列化操作2</strong></h3><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p>
<ul>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>
<li>该类包含未知数据类型 </li>
<li>该类没有可访问的无参数构造方法 </li>
</ul>
<p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 加入序列版本号</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">     <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="keyword">public</span> String address;</span><br><span class="line">     <span class="comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> eid; </span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Address  check : "</span> + name + <span class="string">" -- "</span> + address);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-练习：序列化集合"><a href="#3-4-练习：序列化集合" class="headerlink" title="3.4 练习：序列化集合"></a>3.4 练习：序列化集合</h2><ol>
<li>将存有多个自定义对象的集合序列化操作，保存到 <code>list.txt</code> 文件中。</li>
<li>反序列化 <code>list.txt</code> ，并遍历集合，打印对象信息。</li>
</ol>
<h3 id="案例分析-2"><a href="#案例分析-2" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>把若干学生对象 ，保存到集合中。</li>
<li>把集合序列化。</li>
<li>反序列化读取时，只需要读取一次，转换为集合类型。</li>
<li>遍历集合，可以打印所有的学生信息</li>
</ol>
<h3 id="案例实现-2"><a href="#案例实现-2" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 创建 学生对象</span></span><br><span class="line">		Student student = <span class="keyword">new</span> Student(<span class="string">"老王"</span>, <span class="string">"laow"</span>);</span><br><span class="line">		Student student2 = <span class="keyword">new</span> Student(<span class="string">"老张"</span>, <span class="string">"laoz"</span>);</span><br><span class="line">		Student student3 = <span class="keyword">new</span> Student(<span class="string">"老李"</span>, <span class="string">"laol"</span>);</span><br><span class="line"></span><br><span class="line">		ArrayList&lt;Student&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		arrayList.add(student);</span><br><span class="line">		arrayList.add(student2);</span><br><span class="line">		arrayList.add(student3);</span><br><span class="line">		<span class="comment">// 序列化操作</span></span><br><span class="line">		<span class="comment">// serializ(arrayList);</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 反序列化  </span></span><br><span class="line">		ObjectInputStream ois  = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"list.txt"</span>));</span><br><span class="line">		<span class="comment">// 读取对象,强转为ArrayList类型</span></span><br><span class="line">		ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();</span><br><span class="line">		</span><br><span class="line">      	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++ )&#123;</span><br><span class="line">          	Student s = list.get(i);</span><br><span class="line">        	System.out.println(s.getName()+<span class="string">"--"</span>+ s.getPwd());</span><br><span class="line">      	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serializ</span><span class="params">(ArrayList&lt;Student&gt; arrayList)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 创建 序列化流 </span></span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"list.txt"</span>));</span><br><span class="line">		<span class="comment">// 写出对象</span></span><br><span class="line">		oos.writeObject(arrayList);</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		oos.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-打印流"><a href="#4-打印流" class="headerlink" title="4.打印流"></a>4.打印流</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<h2 id="4-2-PrintStream类"><a href="#4-2-PrintStream类" class="headerlink" title="4.2 PrintStream类"></a>4.2 PrintStream类</h2><h3 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public PrintStream(String fileName)</code>： 使用指定的文件名创建一个新的打印流。</li>
</ul>
<p>构造举例，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"ps.txt"</span>)；</span><br></pre></td></tr></table></figure>
<h3 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h3><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 调用系统的打印流,控制台直接输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 创建打印流,指定文件的名称</span></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"ps.txt"</span>);</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">      	<span class="comment">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O 字节流、字符流</title>
    <url>/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/I-O-%E5%AD%97%E8%8A%82%E6%B5%81%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
    <content><![CDATA[<h2 id="1-IO概述"><a href="#1-IO概述" class="headerlink" title="1.IO概述"></a>1.IO概述</h2><h3 id="1-1-什么是IO"><a href="#1-1-什么是IO" class="headerlink" title="1.1 什么是IO"></a>1.1 什么是IO</h3><p>数据的传输，可以看做是一种数据的<strong>流动</strong>，按照流动的方向，以<strong>内存</strong>为基准，分为 <code>输入input</code>  和 <code>输出output</code>  ，即流向内存是输入流，流出内存的输出流。</p>
<p>Java 中 I/O 操作主要是指使用 <code>java.io</code> 包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据。</p>
<h3 id="1-2-IO的分类"><a href="#1-2-IO的分类" class="headerlink" title="1.2 IO的分类"></a>1.2 IO的分类</h3><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p>
<ul>
<li><strong>输入流</strong> ：把数据从 <code>其他设备</code> 上读取到 <code>内存</code> 中的流。 </li>
<li><strong>输出流</strong> ：把数据从 <code>内存</code>  中写出到 <code>其他设备</code> 上的流。</li>
</ul>
<p>根据数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p>
<ul>
<li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li>
<li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li>
</ul>
<h3 id="1-3-IO的流向说明图解"><a href="#1-3-IO的流向说明图解" class="headerlink" title="1.3 IO的流向说明图解"></a>1.3 IO的流向说明图解</h3><p><img src="/Java/基础知识/I-O-字节流、字符流/1_io.jpg" style="zoom:60%;"></p>
<h3 id="1-4-顶级父类"><a href="#1-4-顶级父类" class="headerlink" title="1.4 顶级父类"></a>1.4 顶级父类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><strong>输入流</strong></th>
<th style="text-align:center">输出流</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>字节流</strong></td>
<td style="text-align:center">字节输入流<br><strong>InputStream</strong></td>
<td style="text-align:center">字节输出流<br><strong>OutputStream</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>字符流</strong></td>
<td style="text-align:center">字符输入流<br><strong>Reader</strong></td>
<td style="text-align:center">字符输出流<br><strong>Writer</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-字节流"><a href="#2-字节流" class="headerlink" title="2.字节流"></a>2.字节流</h2><h3 id="2-1-一切皆为字节"><a href="#2-1-一切皆为字节" class="headerlink" title="2.1 一切皆为字节"></a>2.1 一切皆为字节</h3><p>一切文件数据(文本、图片、视频等)在存储时，都是以<strong>二进制</strong>数字的形式保存，为一个一个的字节，那么传输时同样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<h3 id="2-2-字节输出流【Output-Stream】"><a href="#2-2-字节输出流【Output-Stream】" class="headerlink" title="2.2 字节输出流【Output Stream】"></a>2.2 字节输出流【Output Stream】</h3><p><code>java.io.OutputStream</code> 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li>
<li><code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li>
<li><code>public void write(byte[] b)</code>：将 b.length 字节从指定的字节数组写入此输出流。  </li>
<li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流。  </li>
<li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li>
</ul>
<blockquote>
<p>注意：</p>
<p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
</blockquote>
<h3 id="2-3-FileOutputStream类"><a href="#2-3-FileOutputStream类" class="headerlink" title="2.3 FileOutputStream类"></a>2.3 FileOutputStream类</h3><p><code>OutputStream</code>  有很多子类，我们从最简单的一个子类开始。</p>
<p><code>java.io.FileOutputStream</code>  类是<strong>文件输出流</strong>，用于将数据写出到文件。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File 对象表示的文件。 </li>
<li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个<strong>文件路径</strong>。该路径下，如果没有这个文件，会<strong>创建</strong>该文件。如果有这个文件，会<strong>清空</strong>这个文件的数据。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h4><ol>
<li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">      	fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">      	fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol>
<li>虽然参数为 int 类型四个字节，但是只会保留一个字节的信息写出。</li>
<li>流操作完毕后，必须释放系统资源，调用 <strong>close</strong> 方法。</li>
</ol>
</blockquote>
<ol>
<li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">"黑马程序员"</span>.getBytes();</span><br><span class="line">      	<span class="comment">// 写出字节数组数据</span></span><br><span class="line">      	fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">黑马程序员</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从 off 索引开始，len 个字节，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">"abcde"</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure>
<h4 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h4><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p>
<ul>
<li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li>
<li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。  </li>
</ul>
<p>这两个构造方法，参数中都需要传入一个 boolean 类型的值，<code>true</code>  表示追加数据，<code>false</code>  表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>，<span class="keyword">true</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">"abcde"</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">文件操作前：cd</span><br><span class="line">文件操作后：cdabcde</span><br></pre></td></tr></table></figure>
<h4 id="写出换行"><a href="#写出换行" class="headerlink" title="写出换行"></a>写出换行</h4><p>Windows系统里，换行符号是 <code>\r\n</code> 。</p>
<p>代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);  </span><br><span class="line">      	<span class="comment">// 定义字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] words = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">      	<span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">          	<span class="comment">// 写出一个字节</span></span><br><span class="line">            fos.write(words[i]);</span><br><span class="line">          	<span class="comment">// 写出一个换行, 换行符号转成数组写出</span></span><br><span class="line">            fos.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul>
<li>回车符：回到一行的开头（return）。</li>
<li>换行符：下一行（newline）。</li>
</ul>
</li>
<li>系统中的换行：<ul>
<li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li>
<li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li>
<li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X 开始与 Linux 统一。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="2-4-字节输入流【InputStream】"><a href="#2-4-字节输入流【InputStream】" class="headerlink" title="2.4 字节输入流【InputStream】"></a>2.4 字节输入流【InputStream】</h3><p><code>java.io.InputStream</code> 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li>
<li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li>
<li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li>
</ul>
<blockquote>
<p>注意：</p>
<p>close 方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
</blockquote>
<h3 id="2-5-FileInputStream类"><a href="#2-5-FileInputStream类" class="headerlink" title="2.5 FileInputStream类"></a>2.5 FileInputStream类</h3><p><code>java.io.FileInputStream</code> 类是文件输入流，从文件中读取字节。</p>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li>
<li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name 命名。  </li>
</ul>
<p>当创建一个流对象时，必须传入文件路径。该路径下，如果没有该文件，会抛出<code>FileNotFoundException</code> 。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h4><ol>
<li><p><strong>读取字节</strong>：<code>read</code> 方法，每次可以读取一个字节的数据，提升为 int 类型，读取到文件末尾，返回 <code>-1</code>。</p>
<p>代码使用演示：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>);</span><br><span class="line">      	<span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line">        <span class="keyword">int</span> read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">      	<span class="comment">// 读取到末尾,返回-1</span></span><br><span class="line">       	read = fis.read();</span><br><span class="line">        System.out.println( read);</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>循环改进读取方式，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol>
<li>虽然读取了一个字节，但是会自动提升为 int 类型。</li>
<li>流操作完毕后，必须释放系统资源，调用 close 方法。</li>
</ol>
</blockquote>
<ol>
<li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取 b 的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回 <code>-1</code> ，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">ed</span><br></pre></td></tr></table></figure>
<p>错误数据 <code>d</code>，是由于最后一次读取时，只读取一个字节 <code>e</code>，数组中，上次读取的数据没有被完全替换，所以要通过<code>len</code> ，获取有效的字节，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b，<span class="number">0</span>，len));<span class="comment">//  len 每次读取的有效字节个数</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">e</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<p>使用数组读取，每次读取多个字节，减少了系统间的 IO 操作次数，从而提高了读写的效率，建议开发中使用。</p>
</blockquote>
<h3 id="2-6-字节流练习：图片复制"><a href="#2-6-字节流练习：图片复制" class="headerlink" title="2.6 字节流练习：图片复制"></a>2.6 字节流练习：图片复制</h3><h4 id="复制原理图解"><a href="#复制原理图解" class="headerlink" title="复制原理图解"></a>复制原理图解</h4><p><img src="/Java/基础知识/I-O-字节流、字符流/2_copy.jpg" style="zoom:60%;"></p>
<h4 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h4><p>复制图片文件，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 指定数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test.jpg"</span>);</span><br><span class="line">        <span class="comment">// 1.2 指定目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"test_copy.jpg"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读写数据</span></span><br><span class="line">        <span class="comment">// 2.1 定义数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 2.2 定义长度</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 2.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.4 写出数据</span></span><br><span class="line">            fos.write(b, <span class="number">0</span> , len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<p>流的关闭原则：先开后关，后开先关。</p>
</blockquote>
<h2 id="3-字符流"><a href="#3-字符流" class="headerlink" title="3.字符流"></a>3.字符流</h2><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到<strong>中文字符</strong>时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以 Java 提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p>
<h3 id="3-1-字符输入流【Reader】"><a href="#3-1-字符输入流【Reader】" class="headerlink" title="3.1 字符输入流【Reader】"></a>3.1 字符输入流【Reader】</h3><p><code>java.io.Reader</code> 抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li>
<li><code>public int read()</code>： 从输入流读取一个字符。 </li>
<li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中 。</li>
</ul>
<h3 id="3-2-FileReader类"><a href="#3-2-FileReader类" class="headerlink" title="3.2 FileReader类"></a>3.2 FileReader类</h3><p><code>java.io.FileReader</code> 类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<blockquote>
<p>注意：</p>
<p>字符编码：字节与字符的对应规则。Windows 系统的中文编码默认是 GBK 编码表。</p>
<p>idea 中 UTF-8</p>
<p>字节缓冲区：一个字节数组，用来临时存储字节数据。</p>
</blockquote>
<h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li>
<li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。类似于 FileInputStream 。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"b.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h4><ol>
<li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为 int 类型，读取到文件末尾，返回 <code>-1</code>，循环读取，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FRRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"read.txt"</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：虽然读取了一个字符，但是会自动提升为int类型。</p>
</blockquote>
<ol>
<li><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取 b 的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回 <code>-1</code> ，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FRRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"read.txt"</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存有效字符个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字符数组，作为装字符数据的容器</span></span><br><span class="line">         <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(cbuf));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取有效的字符改进，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"read.txt"</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存有效字符个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字符数组，作为装字符数据的容器</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(cbuf,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-字符输出流【Writer】"><a href="#3-3-字符输出流【Writer】" class="headerlink" title="3.3 字符输出流【Writer】"></a>3.3 字符输出流【Writer】</h3><p><code>java.io.Writer</code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>void write(int c)</code> 写入单个字符。</li>
<li><code>void write(char[] cbuf)</code>写入字符数组。 </li>
<li><code>abstract  void write(char[] cbuf, int off, int len)</code>写入字符数组的某一部分，off 数组的开始索引，len 写的字符个数。 </li>
<li><code>void write(String str)</code>写入字符串。 </li>
<li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li>
<li><code>void flush()</code>  刷新该流的缓冲。  </li>
<li><code>void close()</code> 关闭此流，但要先刷新它。 </li>
</ul>
<h3 id="3-4-FileWriter类"><a href="#3-4-FileWriter类" class="headerlink" title="3.4 FileWriter类"></a>3.4 FileWriter类</h3><p><code>java.io.FileWriter</code> 类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的 File 对象。   </li>
<li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"b.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基本写出数据"><a href="#基本写出数据" class="headerlink" title="基本写出数据"></a>基本写出数据</h4><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">      	fw.write(<span class="string">'b'</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">      	fw.write(<span class="string">'C'</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line">      	fw.write(<span class="number">30000</span>); <span class="comment">// 写出第4个字符，中文编码表中30000对应一个汉字。</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        【注意】关闭资源时,与FileOutputStream不同。</span></span><br><span class="line"><span class="comment">      	 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// fw.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abC田</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol>
<li>虽然参数为 int 类型四个字节，但是只会保留一个字符的信息写出。</li>
<li>未调用 close 方法，数据只是保存到了缓冲区，并未写出到文件中。</li>
</ol>
</blockquote>
<h4 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h4><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要 <code>flush</code> 方法了。</p>
<ul>
<li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li>
<li><code>close</code>：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
<p>代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);</span><br><span class="line">        <span class="comment">// 写出数据，通过flush</span></span><br><span class="line">        fw.write(<span class="string">'刷'</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.write(<span class="string">'新'</span>); <span class="comment">// 继续写出第2个字符，写出成功</span></span><br><span class="line">        fw.flush();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出数据，通过close</span></span><br><span class="line">        fw.write(<span class="string">'关'</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fw.write(<span class="string">'闭'</span>); <span class="comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：即便是 flush 方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p>
</blockquote>
<h4 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h4><ol>
<li><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似 FileOutputStream，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">char</span>[] chars = <span class="string">"浙江大学"</span>.toCharArray();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出字符数组</span></span><br><span class="line">      	fw.write(chars); <span class="comment">// 浙江大学</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是'大'，两个字节，也就是'大学'。</span></span><br><span class="line">        fw.write(b,<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// 大学</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);     </span><br><span class="line">      	<span class="comment">// 字符串</span></span><br><span class="line">      	String msg = <span class="string">"浙江大学"</span>;</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出字符数组</span></span><br><span class="line">      	fw.write(msg); <span class="comment">//浙江大学</span></span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是'大'，两个字节，也就是'大学'。</span></span><br><span class="line">        fw.write(msg,<span class="number">2</span>,<span class="number">2</span>);	<span class="comment">// 大学</span></span><br><span class="line">      	</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>续写和换行</strong>：操作类似于 FileOutputStream。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，可以续写数据</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>，<span class="keyword">true</span>);     </span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">        fw.write(<span class="string">"浙江"</span>);</span><br><span class="line">      	<span class="comment">// 写出换行</span></span><br><span class="line">      	fw.write(<span class="string">"\r\n"</span>);</span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">  		fw.write(<span class="string">"大学"</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果:</span><br><span class="line">浙江</span><br><span class="line">大学</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。</p>
<p>当我们单纯读或者写文本文件时  使用字符流 ，其他情况使用字节流。</p>
</blockquote>
<h2 id="4-IO异常的处理"><a href="#4-IO异常的处理" class="headerlink" title="4.IO异常的处理"></a>4.IO异常的处理</h2><h3 id="JDK7-前处理"><a href="#JDK7-前处理" class="headerlink" title="JDK7 前处理"></a>JDK7 前处理</h3><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用 <code>try...catch...finally</code>  代码块，处理异常部分，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleException1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 声明变量</span></span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建流对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">"浙江大学"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JDK7-的处理"><a href="#JDK7-的处理" class="headerlink" title="JDK7 的处理"></a>JDK7 的处理</h3><p>还可以使用JDK7优化后的 <code>try-with-resource</code>  语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (创建流对象语句，如果多个,使用<span class="string">';'</span>隔开) &#123;</span><br><span class="line">	<span class="comment">// 读写数据</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleException2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> ( FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>); ) &#123;</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">"浙江大学"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JDK9的改进"><a href="#JDK9的改进" class="headerlink" title="JDK9的改进"></a>JDK9的改进</h3><p>JDK9中 <code>try-with-resource</code>  的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。</p>
<p>改进前格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> Resource resource1 = <span class="keyword">new</span> Resource(<span class="string">"resource1"</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line">Resource resource2 = <span class="keyword">new</span> Resource(<span class="string">"resource2"</span>);</span><br><span class="line"><span class="comment">// 引入方式：创建新的变量保存</span></span><br><span class="line"><span class="keyword">try</span> (Resource r1 = resource1;</span><br><span class="line">     Resource r2 = resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进后格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> Resource resource1 = <span class="keyword">new</span> Resource(<span class="string">"resource1"</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line">Resource resource2 = <span class="keyword">new</span> Resource(<span class="string">"resource2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入方式：直接引入</span></span><br><span class="line"><span class="keyword">try</span> (resource1; resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进后，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       	<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">final</span>  FileReader fr  = <span class="keyword">new</span> FileReader(<span class="string">"in.txt"</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"out.txt"</span>);</span><br><span class="line">       	<span class="comment">// 引入到try中</span></span><br><span class="line">        <span class="keyword">try</span> (fr; fw) &#123;</span><br><span class="line">          	<span class="comment">// 定义变量</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">          	<span class="comment">// 读取数据</span></span><br><span class="line">          	<span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            	<span class="comment">// 写出数据</span></span><br><span class="line">            	fw.write(b);</span><br><span class="line">          	&#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-属性集"><a href="#5-属性集" class="headerlink" title="5.属性集"></a>5.属性集</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p><code>java.util.Properties</code>  继承于 <code>Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多 Java 类使用，比如获取系统属性时，<code>System.getProperties</code>  方法就是返回一个 <code>Properties</code> 对象。</p>
<h3 id="5-2-Properties类"><a href="#5-2-Properties类" class="headerlink" title="5.2 Properties类"></a>5.2 Properties类</h3><h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public Properties()</code> ：创建一个空的属性列表。</li>
</ul>
<h4 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h4><ul>
<li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li>
<li><code>public String getProperty(String key)</code> ：使用此属性列表中指定的键搜索属性值。</li>
<li><code>public Set&lt;String&gt; stringPropertyNames()</code> ：所有键的名称的集合。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 添加键值对元素</span></span><br><span class="line">        properties.setProperty(<span class="string">"filename"</span>, <span class="string">"a.txt"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"length"</span>, <span class="string">"209385038"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"location"</span>, <span class="string">"D:\\a.txt"</span>);</span><br><span class="line">        <span class="comment">// 打印属性集对象</span></span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        <span class="comment">// 通过键,获取属性值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">"filename"</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">"length"</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">"location"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历属性集,获取所有键的集合</span></span><br><span class="line">        Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line">        <span class="comment">// 打印键值对</span></span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          	System.out.println(key+<span class="string">" -- "</span>+properties.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">&#123;filename=a.txt, length=<span class="number">209385038</span>, location=D:\a.txt&#125;</span><br><span class="line">a.txt</span><br><span class="line"><span class="number">209385038</span></span><br><span class="line">D:\a.txt</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure>
<h4 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h4><ul>
<li><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。 </li>
</ul>
<p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filename=a.txt</span><br><span class="line">length=209385038</span><br><span class="line">location=D:\a.txt</span><br></pre></td></tr></table></figure>
<p>加载代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 加载文本中信息到属性集</span></span><br><span class="line">        pro.load(<span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>));</span><br><span class="line">        <span class="comment">// 遍历集合并打印</span></span><br><span class="line">        Set&lt;String&gt; strings = pro.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          	System.out.println(key+<span class="string">" -- "</span>+pro.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven中Scope的区别</title>
    <url>/Java/Maven/Maven%E4%B8%ADScope%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h2><p>编译范围，不设置<strong>默认</strong>为 compile，在工程环境的classpath（编译环境）和打包（如果是WAR包，会包含在WAR包中）时候都有效，属于<strong>强依赖</strong>。</p>
<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>该依赖仅仅参与<strong>测试</strong>相关的内容，包括测试用例的编译和执行，一般是单元测试场景使用，在编译环境加入classpath，但打包时不会加入，如 junit 等。</p>
<h2 id="provided"><a href="#provided" class="headerlink" title="provided"></a>provided</h2><p>容器或 JDK 已提供范围，表示该依赖包已经由目标容器（如tomcat）和 JDK 提供，只在编译的 classpath 中加载和使用，打包的时候不会包含在目标包中。最常见的是 j2ee 规范相关的 servlet-api 和 jsp-api 等 jar 包，一般由 servlet 容器提供，无需再打包到 war 包中，如果不配置为 provided ，把这些包打包到工程 war 包中，在 tomcat6 以上版本会出现冲突无法正常运行程序（版本不符的情况）。</p>
<h2 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h2><p>一般是运行和测试环境使用，编译时候不用加入 classpath，打包时候会打包到目标包中。一般是通过动态加载或接口反射加载的情况比较多。一般这种类库都是接口与实现相分离的类库，比如 JDBC 类库，在编译之时仅依赖相关的接口，在具体的运行之时，才需要具体的 mysql、oracle 等等数据的驱动程序。</p>
<h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>使用上与provided相同，不同之处在于该依赖不从maven仓库中提取，而是从本地文件系统中提取，其会参照systemPath的属性进行提取依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sun.jdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/../lib/tools.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>依赖范围</th>
<th style="text-align:center">对于编译有效</th>
<th style="text-align:center">对于测试有效</th>
<th style="text-align:center">对于运行时有效</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:left">spring-core</td>
</tr>
<tr>
<td>test</td>
<td style="text-align:center">—</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">—</td>
<td style="text-align:left">Junit</td>
</tr>
<tr>
<td>provided</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">—</td>
<td style="text-align:left">servlet-api</td>
</tr>
<tr>
<td>runtime</td>
<td style="text-align:center">—</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:left">JDBC驱动</td>
</tr>
<tr>
<td>system</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">—</td>
<td style="text-align:left">Maven仓库之外的本地库</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Java</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="1-卷积神经网络结构"><a href="#1-卷积神经网络结构" class="headerlink" title="1.卷积神经网络结构"></a>1.卷积神经网络结构</h2><p><img style="float: center;" src="/机器学习/卷积神经网络/卷积神经网络结构.png" width="70%"></p>
<ul>
<li><strong>输入层</strong>：将每个像素代表一个特征节点输入到网络中。</li>
<li><strong>卷积层</strong>：卷积运算的主要目的是使原信号特征增强，并降低噪音。</li>
<li><strong>降采样层</strong>：降低网络训练参数及模型的过拟合程度。</li>
<li><strong>全连接层</strong>：对生成的特征进行加权。</li>
</ul>
<h2 id="2-卷积运算"><a href="#2-卷积运算" class="headerlink" title="2.卷积运算"></a>2.卷积运算</h2><ul>
<li>1.<strong>求点积</strong>：将5×5输入矩阵中3×3深蓝色区域中每个元素分别与其对应位置的权值（红色数字）相乘，然后再相加，所得到的值作为3×3输出矩阵（绿色）的第一个元素。  </li>
<li>2.<strong>滑动窗口</strong>：将3×3权值矩阵向右移动一个格（即，步长为1）。  </li>
<li>3.<strong>重复操作</strong>：同样地，将此时深色区域内每个元素分别与对应的权值相乘然后再相加，所得到的值作为输出矩阵的第二个元素；重复上述“求点积-滑动窗口”操作，直至输出矩阵所有值被填满。</li>
</ul>
<p><img style="float: center;" src="/机器学习/卷积神经网络/卷积操作.png" width="60%"></p>
<p><strong>注意点</strong>：</p>
<ul>
<li>卷积核在2 维输入数据上“滑动”，对当前输入部分的元素进行矩阵乘法，然后将结果汇为单个输出像素值，重复这个过程直到遍历整张图像，这个过程就叫做卷积  </li>
<li>这个权值矩阵就是<strong>卷积核</strong>  </li>
<li>卷积操作后的图像称为<strong>特征图</strong>（feature map）</li>
</ul>
<h2 id="3-全连接层和卷积层对比"><a href="#3-全连接层和卷积层对比" class="headerlink" title="3.全连接层和卷积层对比"></a>3.全连接层和卷积层对比</h2><p><img style="float: center;" src="/机器学习/卷积神经网络/全连接层和卷积层对比.png" width="60%"></p>
<h2 id="4-卷积的作用"><a href="#4-卷积的作用" class="headerlink" title="4.卷积的作用"></a>4.卷积的作用</h2><ul>
<li>卷积运算的主要目的是<strong>使原信号特征增强，并降低噪音</strong>。  </li>
<li>对图像用一个卷积核进行卷积运算，实际上是一个滤波的过程。每个卷积核都是一种特征提取方式，就像是一个筛子，将图像中符合条件的部分筛选出来。  </li>
</ul>
<p><img style="float: center;" src="/机器学习/卷积神经网络/卷积示意图.png" width="50%"></p>
<h2 id="5-填充（Padding）"><a href="#5-填充（Padding）" class="headerlink" title="5.填充（Padding）"></a>5.填充（Padding）</h2><p>在卷积核滑动过程中图像边缘会被裁剪掉，将5×5的特征矩阵转换为3×3的特征矩阵。<br><strong>填充</strong>：用额外的“假”像素（通常值为0）填充边缘。这样，在滑动时的卷积核可以允许原始边缘像素位于卷积核的中心，同时延伸到边缘之外的假像素，从而产生与输入（5×5蓝色）相同大小的输出（5×5绿色）。  </p>
<p><img style="float: center;" src="/机器学习/卷积神经网络/填充.png" width="20%"></p>
<h2 id="6-多通道卷积"><a href="#6-多通道卷积" class="headerlink" title="6.多通道卷积"></a>6.多通道卷积</h2><ul>
<li>每个卷积核都会将图像生成为另一幅特征映射图，即：<strong>一个卷积核提取一种特征</strong>。  </li>
<li>为了使特征提取更充分，可以添加多个卷积核以提取不同的特征，也就是，<strong>多通道卷积</strong>。  </li>
</ul>
<p><img style="float: center;" src="/机器学习/卷积神经网络/特征筛选.png" width="20%"></p>
<p><img style="float: center;" src="/机器学习/卷积神经网络/desktop/研究周报/机器学习/卷积神经网络/img/多通道卷积.png" width="40%"></p>
<h2 id="7-池化（pooling）"><a href="#7-池化（pooling）" class="headerlink" title="7.池化（pooling）"></a>7.池化（pooling）</h2><p><strong>池化</strong>：计算图像一个区域上的某个特定特征的平均值或最大值的聚合操作。<br>卷积层的作用是探测上一层特征的局部连接，而池化的作用是<strong>在语义上将相似的特征合并起来</strong>，从而达到降维的目的。  </p>
<p><strong>常用池化方法</strong></p>
<ul>
<li>1.<strong>均值池化</strong>：对池化区域内的像素点取均值，这种方法得到的特征数据对背景信息更敏感。  </li>
<li>2.<strong>最大池化</strong>：对池化区域内所有像素点取最大值，这种方法得到的特征对纹理特征信息更加敏感。</li>
</ul>
<p><img style="float: center;" src="/机器学习/卷积神经网络/最大池化.png" width="40%"></p>
<h2 id="8-步长（stride）"><a href="#8-步长（stride）" class="headerlink" title="8.步长（stride）"></a>8.步长（stride）</h2><p><strong>步长</strong>：卷积核在图片上移动的格数。  </p>
<ul>
<li>stride=1：</li>
</ul>
<p><img style="float: center;" src="/机器学习/卷积神经网络/stride1.png" width="50%"></p>
<ul>
<li>stride=2:</li>
</ul>
<p><img style="float: center;" src="/机器学习/卷积神经网络/stride2.png" width="50%"></p>
<p>步长大于1的卷积操作也是<strong>降维的一种方式</strong>。<br>卷积后图片尺寸：假如步长为S，原始图片尺寸为$[N_1,N_1]$，卷积核大小为$[N_2,N_2]$，那么<strong>卷积之后图像大小</strong>：<br>$[\frac{N_1-N_2}{S}+1,\frac{N_1-N_2}{S}+1]$</p>
<h2 id="9-卷积神经网络组成小结"><a href="#9-卷积神经网络组成小结" class="headerlink" title="9.卷积神经网络组成小结"></a>9.卷积神经网络组成小结</h2><p><img style="float: center;" src="/机器学习/卷积神经网络/卷积神经网络组成.png" width="50%"></p>
<p>正则表达式：<br>输入层→(卷积层+→池化层?)+→全连接层+<br>含义：<strong>输入层</strong>→(<strong>卷积层</strong>[一层或多层]+<strong>池化层</strong>[0或1层])[一个或多个]→<strong>全连接层</strong>[一个或多个]</p>
<h2 id="10-Tensorflow实践"><a href="#10-Tensorflow实践" class="headerlink" title="10.Tensorflow实践"></a>10.Tensorflow实践</h2><p>CIFAR10 数据集</p>
<p><img src="/机器学习/卷积神经网络/desktop\9.卷积神经网络\img\CIFAR10.png" alt="CIFAR10" style="zoom:60%;"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> pickle <span class="keyword">as</span> p</span><br><span class="line">%load_ext tensorboard</span><br></pre></td></tr></table></figure>
<h3 id="9-1-导入CIFAR数据集"><a href="#9-1-导入CIFAR数据集" class="headerlink" title="9.1 导入CIFAR数据集"></a>9.1 导入CIFAR数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(Xtrain,Ytrain),(Xtest,Ytest) = tf.keras.datasets.cifar10.load_data()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看训练和测试数据集大小</span></span><br><span class="line">print(<span class="string">"Xtrain's shape:"</span>,Xtrain.shape)</span><br><span class="line">print(<span class="string">"Ytrain's shape:"</span>,Ytrain.shape)</span><br><span class="line">print(<span class="string">"Xtest's shape:"</span>,Xtest.shape)</span><br><span class="line">print(<span class="string">"Ytest's shape:"</span>,Ytest.shape)</span><br></pre></td></tr></table></figure>
<pre><code>Xtrain&#39;s shape: (50000, 32, 32, 3)
Ytrain&#39;s shape: (50000, 1)
Xtest&#39;s shape: (10000, 32, 32, 3)
Ytest&#39;s shape: (10000, 1)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看图像数据和标签</span></span><br><span class="line">label_dict = &#123;<span class="number">0</span>:<span class="string">'T-shirt/top'</span>,<span class="number">1</span>:<span class="string">'Trouser'</span>,<span class="number">2</span>:<span class="string">'Pullover'</span>,<span class="number">3</span>:<span class="string">'Dress'</span>,<span class="number">4</span>:<span class="string">'Coat'</span>,</span><br><span class="line">             <span class="number">5</span>:<span class="string">'Sandal'</span>,<span class="number">6</span>:<span class="string">'Shirt'</span>,<span class="number">7</span>:<span class="string">'Sneaker'</span>,<span class="number">8</span>:<span class="string">'Bag'</span>,<span class="number">9</span>:<span class="string">'Ankle boot'</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_images_labels</span><span class="params">(images,labels,prediction,idx,num=<span class="number">10</span>)</span>:</span></span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>))</span><br><span class="line">    labels = np.array(labels)</span><br><span class="line">    <span class="keyword">if</span> num&gt;<span class="number">10</span>:</span><br><span class="line">        num=<span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">        plt.subplot(<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>+i)</span><br><span class="line">        plt.imshow(images[idx],cmap=<span class="string">'binary'</span>)</span><br><span class="line">        title=str(i+<span class="number">1</span>)+<span class="string">'.'</span>+label_dict[labels[idx,<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">if</span> len(prediction)&gt;<span class="number">0</span>:</span><br><span class="line">            title+=<span class="string">'=&gt;'</span>+label_dict[prediction[idx]]</span><br><span class="line">        plt.title(title,fontsize=<span class="number">10</span>)</span><br><span class="line">        idx+=<span class="number">1</span></span><br><span class="line">plot_images_labels(Xtest,Ytest,[],<span class="number">10</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/机器学习/卷积神经网络/output_16_0.png" alt="png"></p>
<h3 id="9-2-数据预处理"><a href="#9-2-数据预处理" class="headerlink" title="9.2 数据预处理"></a>9.2 数据预处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 图像数据数字标准化</span></span><br><span class="line">Xtrain_norm = Xtrain.astype(<span class="string">'float32'</span>)/<span class="number">255.0</span></span><br><span class="line">Xtest_norm = Xtest.astype(<span class="string">'float32'</span>)/<span class="number">255.0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 独热编码</span></span><br><span class="line"><span class="comment"># Ytrain_onehot = tf.one_hot(Ytrain,depth=10)</span></span><br><span class="line"><span class="comment"># Ytest_onehot = tf.one_hot(Ytest,depth=10)</span></span><br></pre></td></tr></table></figure>
<h3 id="9-3-建立模型"><a href="#9-3-建立模型" class="headerlink" title="9.3 建立模型"></a>9.3 建立模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = tf.keras.Sequential()</span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>, input_shape=(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>)))</span><br><span class="line">model.add(tf.keras.layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(tf.keras.layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(tf.keras.layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(tf.keras.layers.Flatten())</span><br><span class="line">model.add(tf.keras.layers.Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure>
<pre><code>Model: &quot;sequential_18&quot;
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
conv2d_35 (Conv2D)           (None, 30, 30, 32)        896       
_________________________________________________________________
max_pooling2d_12 (MaxPooling (None, 15, 15, 32)        0         
_________________________________________________________________
conv2d_36 (Conv2D)           (None, 13, 13, 64)        18496     
_________________________________________________________________
max_pooling2d_13 (MaxPooling (None, 6, 6, 64)          0         
_________________________________________________________________
conv2d_37 (Conv2D)           (None, 4, 4, 64)          36928     
_________________________________________________________________
flatten_12 (Flatten)         (None, 1024)              0         
_________________________________________________________________
dense_22 (Dense)             (None, 64)                65600     
_________________________________________________________________
dense_23 (Dense)             (None, 10)                650       
=================================================================
Total params: 122,570
Trainable params: 122,570
Non-trainable params: 0
_________________________________________________________________
</code></pre><h3 id="9-4-编译模型"><a href="#9-4-编译模型" class="headerlink" title="9.4 编译模型"></a>9.4 编译模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型编译</span></span><br><span class="line">model.compile(optimizer=<span class="string">'adam'</span>,</span><br><span class="line">             loss=<span class="string">'sparse_categorical_crossentropy'</span>,</span><br><span class="line">             metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">log_dir = <span class="string">"F:\\JupyterNotebook\\TensorFlowLearn\\logs\\"</span> + datetime.datetime.now().strftime(<span class="string">"%Y%m%d-%H%M%S"</span>)</span><br><span class="line">tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=log_dir, histogram_freq=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="9-5-训练模型"><a href="#9-5-训练模型" class="headerlink" title="9.5 训练模型"></a>9.5 训练模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">his = model.fit(Xtrain_norm,Ytrain,epochs=<span class="number">5</span>,validation_data=(Xtest_norm,Ytest),callbacks=[tensorboard_callback])</span><br></pre></td></tr></table></figure>
<pre><code>Train on 50000 samples, validate on 10000 samples
Epoch 1/5
   32/50000 [..............................] - ETA: 8:18 - loss: 2.3121 - accuracy: 0.0312WARNING:tensorflow:Method (on_train_batch_end) is slow compared to the batch update (0.103193). Check your callbacks.
50000/50000 [==============================] - 23s 452us/sample - loss: 1.5411 - accuracy: 0.4347 - val_loss: 1.2904 - val_accuracy: 0.5303
Epoch 2/5
50000/50000 [==============================] - 22s 440us/sample - loss: 1.1496 - accuracy: 0.5928 - val_loss: 1.1249 - val_accuracy: 0.6020
Epoch 3/5
50000/50000 [==============================] - 22s 449us/sample - loss: 0.9963 - accuracy: 0.6501 - val_loss: 0.9654 - val_accuracy: 0.6617
Epoch 4/5
50000/50000 [==============================] - 23s 455us/sample - loss: 0.8942 - accuracy: 0.6858 - val_loss: 0.9129 - val_accuracy: 0.6794
Epoch 5/5
50000/50000 [==============================] - 23s 455us/sample - loss: 0.8187 - accuracy: 0.7118 - val_loss: 0.9052 - val_accuracy: 0.6840
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">his.history.keys()</span><br></pre></td></tr></table></figure>
<pre><code>dict_keys([&#39;loss&#39;, &#39;accuracy&#39;, &#39;val_loss&#39;, &#39;val_accuracy&#39;])
</code></pre><h3 id="9-6-训练结果"><a href="#9-6-训练结果" class="headerlink" title="9.6 训练结果"></a>9.6 训练结果</h3><p>模型训练后的准确率为<strong>68.4%</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(his.epoch,his.history.get(<span class="string">'loss'</span>),label=<span class="string">'trainset_loss'</span>)</span><br><span class="line">plt.plot(his.epoch,his.history.get(<span class="string">'val_loss'</span>),label=<span class="string">'testset_loss'</span>)</span><br><span class="line">plt.legend(fontsize=<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/机器学习/卷积神经网络/output_26_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(his.epoch,his.history.get(<span class="string">'accuracy'</span>),label=<span class="string">'trainset_accuracy'</span>)</span><br><span class="line">plt.plot(his.epoch,his.history.get(<span class="string">'val_accuracy'</span>),label=<span class="string">'testset_accuracy'</span>)</span><br><span class="line">plt.legend(fontsize=<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/机器学习/卷积神经网络/output_27_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prediction = model.predict(Xtest_norm)</span><br><span class="line">prediction = np.argmax(prediction,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot_images_labels(Xtest,Ytest,prediction,<span class="number">10</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/机器学习/卷积神经网络/output_29_0.png" alt="png"></p>
<p>可见第1和第6幅图预测错误，本次训练只进行了5轮，仍有比较大的改进空间。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记</title>
    <url>/Java/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>redis 是一款高性能的 NoSQL系列的非关系型数据库。</p>
<h3 id="1-1-NoSQL"><a href="#1-1-NoSQL" class="headerlink" title="1.1 NoSQL"></a>1.1 NoSQL</h3><p><strong>NoSQL</strong>(NoSQL = Not Only SQL)，意即“不仅仅是 SQL”，是一项全新的数据库理念，泛指非关系型的数据库。</p>
<p>随着互联网 web2.0 网站的兴起，传统的关系数据库在应付 web2.0 网站，特别是超大规模和高并发的 SNS 类型的 web2.0 <strong>纯动态</strong>网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL 数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是<strong>大数据应用</strong>难题。</p>
<h4 id="NoSQL和关系型数据库比较"><a href="#NoSQL和关系型数据库比较" class="headerlink" title="NoSQL和关系型数据库比较"></a>NoSQL和关系型数据库比较</h4><p><strong>优点：</strong></p>
<ul>
<li>成本：NoSQL 数据库<strong>简单易部署</strong>，基本都是开源软件，相比关系型数据库<strong>价格便宜</strong>。</li>
<li>查询速度：NoSQL 数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，<strong>查询速度</strong>远不及 NoSQL 数据库。</li>
<li>存储数据的格式：NoSQL 的存储格式是 key,value 形式、文档形式、图片形式等等，所以可以<strong>存储基础类型</strong>以及对象或者是集合等各种格式，而数据库则只支持基础类型。</li>
<li>扩展性：关系型数据库有类似 join 这样的多表查询机制的限制导致扩展很艰难。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>维护的工具和资料有限，因为 NoSQL 是属于新的技术，不能和关系型数据库十几年的技术同日而语。</li>
<li>不提供对 sql 的支持，如果不支持 sql 这样的工业标准，将产生一定用户的学习和使用成本。</li>
<li>不提供关系型数据库对事务的处理。</li>
</ul>
<h4 id="非关系型数据库的优势"><a href="#非关系型数据库的优势" class="headerlink" title="非关系型数据库的优势"></a>非关系型数据库的优势</h4><ul>
<li>NoSQL 是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过 SQL 层的解析，所以<strong>性能非常高</strong>。</li>
<li>可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易<strong>水平扩展</strong>。</li>
</ul>
<h4 id="关系型数据库的优势"><a href="#关系型数据库的优势" class="headerlink" title="关系型数据库的优势"></a>关系型数据库的优势</h4><ul>
<li>复杂查询可以用 SQL 语句方便的在一个表以及多个表之间做非常<strong>复杂的数据查询</strong>。</li>
<li><strong>事务支持</strong>使得对于安全性能很高的数据访问要求得以实现。</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>关系型数据库与 NoSQL 数据库并非对立而是<strong>互补</strong>的关系，即通常情况下使用关系型数据库，在适合使用 NoSQL 的时候使用 NoSQL 数据库，让 NoSQ L数据库对关系型数据库的不足进行弥补。</li>
<li>一般会将数据存储在关系型数据库中，在 NoSQL 数据库中<strong>备份</strong>存储关系型数据库的数据</li>
</ul>
<h3 id="1-2-主流的-NoSQL-产品"><a href="#1-2-主流的-NoSQL-产品" class="headerlink" title="1.2 主流的 NoSQL 产品"></a>1.2 主流的 NoSQL 产品</h3><h4 id="键值-Key-Value-存储数据库"><a href="#键值-Key-Value-存储数据库" class="headerlink" title="键值(Key-Value)存储数据库"></a>键值(Key-Value)存储数据库</h4><ul>
<li>相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB。</li>
<li>典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 </li>
<li>数据模型： 一系列键值对。</li>
<li>优势： 快速查询。</li>
<li>劣势： 存储的数据缺少结构化。</li>
</ul>
<h4 id="列存储数据库"><a href="#列存储数据库" class="headerlink" title="列存储数据库"></a>列存储数据库</h4><ul>
<li>相关产品：Cassandra, HBase, Riak。</li>
<li>典型应用：分布式的文件系统。</li>
<li>数据模型：以列簇式存储，将同一列数据存在一起。</li>
<li>优势：查找速度快，可扩展性强，更容易进行分布式扩展。</li>
<li>劣势：功能相对局限。</li>
</ul>
<h4 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h4><ul>
<li>相关产品：CouchDB、MongoDB。</li>
<li>典型应用：Web应用（与Key-Value类似，Value是结构化的）。</li>
<li>数据模型： 一系列键值对。</li>
<li>优势：数据结构要求不严格。</li>
<li>劣势： 查询性能不高，而且缺乏统一的查询语法。</li>
</ul>
<h4 id="图形-Graph-数据库"><a href="#图形-Graph-数据库" class="headerlink" title="图形(Graph)数据库"></a>图形(Graph)数据库</h4><ul>
<li>相关数据库：Neo4J、InfoGrid、Infinite Graph。</li>
<li>典型应用：社交网络。</li>
<li>数据模型：图结构。</li>
<li>优势：利用图结构相关算法。</li>
<li>劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</li>
</ul>
<h3 id="1-3-什么是-Redis"><a href="#1-3-什么是-Redis" class="headerlink" title="1.3 什么是 Redis"></a>1.3 什么是 Redis</h3><p>Redis 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50 个并发执行 100000 个请求,读的速度是 110000 次/s，写的速度是 81000 次/s ，且 Redis 通过提供多种键值数据类型来适应不同场景下的存储需求。</p>
<h4 id="Redis-的应用场景"><a href="#Redis-的应用场景" class="headerlink" title="Redis 的应用场景"></a>Redis 的应用场景</h4><ul>
<li>缓存（数据查询、短连接、新闻内容、商品内容等等）。</li>
<li>聊天室的在线好友列表。</li>
<li>任务队列。（秒杀、抢购、12306 等等）。</li>
<li>应用排行榜。</li>
<li>网站访问统计。</li>
<li>数据过期处理（可以精确到毫秒）。</li>
<li>分布式集群架构中的 session 分离。</li>
</ul>
<h2 id="2-下载安装"><a href="#2-下载安装" class="headerlink" title="2.下载安装"></a>2.下载安装</h2><ul>
<li><a href="https://redis.io/" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://www.redis.net.cn/" target="_blank" rel="noopener">中文网</a></li>
<li>解压直接可以使用：<ul>
<li>redis.windows.conf：<strong>配置文件</strong></li>
<li>redis-cli.exe：redis的<strong>客户端</strong></li>
<li>redis-server.exe：redis<strong>服务器端</strong></li>
</ul>
</li>
</ul>
<h2 id="3-命令操作"><a href="#3-命令操作" class="headerlink" title="3.命令操作"></a>3.命令操作</h2><h3 id="3-1-Redis-的数据结构"><a href="#3-1-Redis-的数据结构" class="headerlink" title="3.1 Redis 的数据结构"></a>3.1 Redis 的数据结构</h3><p>Redis 存储的是：key,value 格式的数据，其中 key 都是<strong>字符串</strong>，value 有 5 种不同的数据结构：</p>
<ul>
<li>字符串类型 string</li>
<li>哈希类型 hash：map 格式 。</li>
<li>列表类型 list：linkedlist 格式，<strong>支持重复元素</strong>。</li>
<li>集合类型 set：<strong>不允许重复元素</strong>。</li>
<li>有序集合类型 sortedset：<strong>不允许重复元素</strong>，且元素有顺序。</li>
</ul>
<h3 id="3-2-字符串类型-string"><a href="#3-2-字符串类型-string" class="headerlink" title="3.2 字符串类型 string"></a>3.2 字符串类型 string</h3><ul>
<li>存储： set key value</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> username zhangsan</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<ul>
<li>获取： get key</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get username</span><br><span class="line"><span class="string">"zhangsan"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除： del key</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del age</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<h3 id="3-3-哈希类型-hash"><a href="#3-3-哈希类型-hash" class="headerlink" title="3.3 哈希类型 hash"></a>3.3 哈希类型 hash</h3><ul>
<li>存储： hset key field value</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash username lisi</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset myhash password 123</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<ul>
<li>获取：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hget key field: 获取指定的field对应的值。</span></span><br><span class="line">127.0.0.1:6379&gt; hget myhash username</span><br><span class="line"><span class="string">"lisi"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hgetall key：获取所有的field和value。</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">"username"</span></span><br><span class="line">2) <span class="string">"lisi"</span></span><br><span class="line">3) <span class="string">"password"</span></span><br><span class="line">4) <span class="string">"123"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除： hdel key field</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel myhash username</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<h3 id="3-4-列表类型-list"><a href="#3-4-列表类型-list" class="headerlink" title="3.4 列表类型 list"></a>3.4 列表类型 list</h3><p>可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<ul>
<li>添加：<ul>
<li>lpush key value: 将元素加入列表左表。</li>
<li>rpush key value：将元素加入列表右边。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush myList a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush myList b</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush myList c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>
<ul>
<li>获取：lrange key start end ：范围获取。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange myList 0 -1</span><br><span class="line">1) <span class="string">"b"</span></span><br><span class="line">2) <span class="string">"a"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除：<ul>
<li>lpop key： 删除列表最左边的元素，并将元素返回。</li>
<li>rpop key： 删除列表最右边的元素，并将元素返回。</li>
</ul>
</li>
</ul>
<h3 id="3-5-集合类型-set"><a href="#3-5-集合类型-set" class="headerlink" title="3.5 集合类型 set"></a>3.5 集合类型 set</h3><ul>
<li>存储：sadd key value</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
<ul>
<li>获取：smembers key：获取 set 集合中所有元素。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">"a"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除：srem key value：删除 set 集合中的某个元素。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srem myset a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<h3 id="3-6-有序集合类型-sortedset"><a href="#3-6-有序集合类型-sortedset" class="headerlink" title="3.6 有序集合类型 sortedset"></a>3.6 有序集合类型 sortedset</h3><p>不允许重复元素，且元素有顺序。每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
<ul>
<li>存储：zadd key score value</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd mysort 60 zhangsan</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 50 lisi</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 80 wangwu</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<ul>
<li>获取：zrange key start end [withscores]</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange mysort 0 -1</span><br><span class="line">1) <span class="string">"lisi"</span></span><br><span class="line">2) <span class="string">"zhangsan"</span></span><br><span class="line">3) <span class="string">"wangwu"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrange mysort 0 -1 withscores</span><br><span class="line">1) <span class="string">"zhangsan"</span></span><br><span class="line">2) <span class="string">"60"</span></span><br><span class="line">3) <span class="string">"wangwu"</span></span><br><span class="line">4) <span class="string">"80"</span></span><br><span class="line">5) <span class="string">"lisi"</span></span><br><span class="line">6) <span class="string">"500"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除：zrem key value</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrem mysort lisi</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<h3 id="3-7-通用命令"><a href="#3-7-通用命令" class="headerlink" title="3.7 通用命令"></a>3.7 通用命令</h3><ul>
<li>keys * : 查询所有的键。</li>
<li>type key ： 获取键对应的 value 的类型。</li>
<li>del key：删除指定的key value。</li>
</ul>
<h2 id="4-持久化层"><a href="#4-持久化层" class="headerlink" title="4.持久化层"></a>4.持久化层</h2><p>redis 是一个内存数据库，当 redis 服务器重启，或电脑重启，数据会丢失，我们可以将 redis 内存中的数据持久化保存到硬盘的文件中。</p>
<p>redis <strong>持久化机制</strong>：</p>
<ul>
<li><p>RDB：默认方式，不需要进行配置，在一定的间隔时间中，检测 key 的变化情况，然后持久化数据。</p>
<ul>
<li><p>1.编辑 redis.windwos.conf  文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#   after 900 sec (15 min) if at least 1 key changed</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment">#   after 300 sec (5 min) if at least 10 keys changed</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="comment">#   after 60 sec if at least 10000 keys changed</span></span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.重新启动 redis 服务器，并指定配置文件名称。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\JavaWeb2018\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据。</p>
<ul>
<li>编辑 redis.windwos.conf 文件。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly no（关闭aof） --&gt; appendonly yes （开启aof）</span><br><span class="line">				</span><br><span class="line"><span class="comment"># appendfsync always ： 每一次操作都进行持久化</span></span><br><span class="line">appendfsync everysec ： 每隔一秒进行一次持久化</span><br><span class="line"><span class="comment"># appendfsync no	 ： 不进行持久化</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-Java客户端-Jedis"><a href="#5-Java客户端-Jedis" class="headerlink" title="5.Java客户端 Jedis"></a>5.Java客户端 Jedis</h2><p>Jedis: 一款 java 操作 redis 数据库的工具。</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul>
<li>下载 jedis 的 jar 包。</li>
<li>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//2. 操作</span></span><br><span class="line">jedis.set(<span class="string">"username"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line"><span class="comment">//3. 关闭连接</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>
<h3 id="操作数据"><a href="#操作数据" class="headerlink" title="操作数据"></a>操作数据</h3><ul>
<li>字符串类型 string</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line"><span class="comment">//2. 操作</span></span><br><span class="line"><span class="comment">//存储</span></span><br><span class="line">jedis.set(<span class="string">"username"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line">String username = jedis.get(<span class="string">"username"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用setex()方法存储可以指定过期时间的 key value</span></span><br><span class="line">jedis.setex(<span class="string">"activecode"</span>,<span class="number">20</span>,<span class="string">"hehe"</span>);<span class="comment">//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 关闭连接</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>
<ul>
<li>哈希类型 hash ： map格式 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储hash</span></span><br><span class="line">jedis.hset(<span class="string">"user"</span>,<span class="string">"name"</span>,<span class="string">"lisi"</span>);</span><br><span class="line">jedis.hset(<span class="string">"user"</span>,<span class="string">"age"</span>,<span class="string">"23"</span>);</span><br><span class="line">jedis.hset(<span class="string">"user"</span>,<span class="string">"gender"</span>,<span class="string">"female"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取hash</span></span><br><span class="line">String name = jedis.hget(<span class="string">"user"</span>, <span class="string">"name"</span>);</span><br><span class="line"><span class="comment">// 获取hash的所有map中的数据</span></span><br><span class="line">Map&lt;String, String&gt; user = jedis.hgetAll(<span class="string">"user"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// keyset</span></span><br><span class="line">Set&lt;String&gt; keySet = user.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">    <span class="comment">//获取value</span></span><br><span class="line">    String value = user.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">":"</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>列表类型 list ： linkedlist格式，支持重复元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list 存储</span></span><br><span class="line">jedis.lpush(<span class="string">"mylist"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);<span class="comment">//从左边存</span></span><br><span class="line">jedis.rpush(<span class="string">"mylist"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);<span class="comment">//从右边存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// list 范围获取</span></span><br><span class="line">List&lt;String&gt; mylist = jedis.lrange(<span class="string">"mylist"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list 弹出</span></span><br><span class="line">String element1 = jedis.lpop(<span class="string">"mylist"</span>);<span class="comment">//c</span></span><br><span class="line"></span><br><span class="line">String element2 = jedis.rpop(<span class="string">"mylist"</span>);<span class="comment">//c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// list 范围获取</span></span><br><span class="line">List&lt;String&gt; mylist2 = jedis.lrange(<span class="string">"mylist"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>集合类型 set  ： 不允许重复元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set 存储</span></span><br><span class="line">jedis.sadd(<span class="string">"myset"</span>,<span class="string">"java"</span>,<span class="string">"php"</span>,<span class="string">"c++"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 获取</span></span><br><span class="line">Set&lt;String&gt; myset = jedis.smembers(<span class="string">"myset"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>有序集合类型 sortedset：不允许重复元素，且元素有顺序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sortedset 存储</span></span><br><span class="line">jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">3</span>,<span class="string">"亚瑟"</span>);</span><br><span class="line">jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">30</span>,<span class="string">"后羿"</span>);</span><br><span class="line">jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">55</span>,<span class="string">"孙悟空"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sortedset 获取</span></span><br><span class="line">Set&lt;String&gt; mysortedset = jedis.zrange(<span class="string">"mysortedset"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Jedis-连接池：JedisPool"><a href="#Jedis-连接池：JedisPool" class="headerlink" title="Jedis 连接池：JedisPool"></a>Jedis 连接池：JedisPool</h3><p><strong>使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0.创建一个配置对象</span></span><br><span class="line">JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">config.setMaxTotal(<span class="number">50</span>);</span><br><span class="line">config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建Jedis连接池对象</span></span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config,<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取连接</span></span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line"><span class="comment">//3. 使用</span></span><br><span class="line">jedis.set(<span class="string">"hehe"</span>,<span class="string">"heihei"</span>);</span><br><span class="line"><span class="comment">//4. 关闭 归还到连接池中</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>
<p><strong>连接池工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        InputStream is = JedisPoolUtils.class.getClassLoader()</span><br><span class="line">            .getResourceAsStream(<span class="string">"jedis.properties"</span>);</span><br><span class="line">        <span class="comment">//创建Properties对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//关联文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取数据，设置到JedisPoolConfig中</span></span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">"maxTotal"</span>)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">"maxIdle"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化JedisPool</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(config,pro.getProperty(<span class="string">"host"</span>),</span><br><span class="line">                                  Integer.parseInt(pro.getProperty(<span class="string">"port"</span>)));</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取连接方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-案例"><a href="#6-案例" class="headerlink" title="6.案例"></a>6.案例</h2><p>案例需求：</p>
<ul>
<li>提供 index.html 页面，页面中有一个省份 下拉列表。</li>
<li>当 页面加载完成后，发送 ajax 请求，加载所有省份。</li>
</ul>
<p>注意：</p>
<ul>
<li>使用 redis 缓存一些不经常发生变化的数据。</li>
<li>数据库的数据一旦发生改变，则需要更新缓存。</li>
</ul>
<p><a href="https://gitee.com/TommyMerlin/code-host/tree/master/Java/redis" target="_blank" rel="noopener">代码</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Bootstrap学习笔记</title>
    <url>/%E5%89%8D%E7%AB%AF/Bootstrap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://www.bootcss.com/" target="_blank" rel="noopener">官网</a></p>
<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>一个前端开发的<strong>框架</strong>，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 基于 HTML、CSS、JavaScript ，简洁灵活，使得 Web 开发更加快捷。</p>
<p><strong>响应式布局</strong>：同一套页面可以兼容不同分辨率的设备。</p>
<h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h2><ul>
<li>1.下载 Bootstrap。</li>
<li>2.在项目中将三个文件夹复制。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bootstrap/</span><br><span class="line">├── css/</span><br><span class="line">│   ├── bootstrap.css</span><br><span class="line">│   ├── bootstrap.css.map</span><br><span class="line">│   ├── bootstrap.min.css</span><br><span class="line">│   ├── bootstrap.min.css.map</span><br><span class="line">│   ├── bootstrap-theme.css</span><br><span class="line">│   ├── bootstrap-theme.css.map</span><br><span class="line">│   ├── bootstrap-theme.min.css</span><br><span class="line">│   └── bootstrap-theme.min.css.map</span><br><span class="line">├── js/</span><br><span class="line">│   ├── bootstrap.js</span><br><span class="line">│   └── bootstrap.min.js</span><br><span class="line">└── fonts/</span><br><span class="line">    ├── glyphicons-halflings-regular.eot</span><br><span class="line">    ├── glyphicons-halflings-regular.svg</span><br><span class="line">    ├── glyphicons-halflings-regular.ttf</span><br><span class="line">    ├── glyphicons-halflings-regular.woff</span><br><span class="line">    └── glyphicons-halflings-regular.woff2</span><br></pre></td></tr></table></figure>
<ul>
<li>3.创建html页面，引入必要的资源文件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Bootstrap Hello World<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery-3.2.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-响应式布局"><a href="#3-响应式布局" class="headerlink" title="3.响应式布局"></a>3.响应式布局</h2><p>同一套页面可以兼容<strong>不同分辨率</strong>的设备。</p>
<p>实现：依赖于<strong>栅格系统</strong>：将一行平均分成12个格子，可以指定元素占几个格子。</p>
<p>步骤：</p>
<ul>
<li>定义容器，相当于 table。<ul>
<li>容器分类：<ul>
<li>container：两边留白。</li>
<li>container-fluid：每一种设备都是100%宽度。</li>
</ul>
</li>
</ul>
</li>
<li>定义行，相当于 tr 。  样式：row</li>
<li>定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目。<ul>
<li>xs：超小屏幕 手机 (&lt;768px)：col-xs-12</li>
<li>sm：小屏幕 平板 (≥768px)</li>
<li>md：中等屏幕 桌面显示器 (≥992px)</li>
<li>lg：大屏幕 大桌面显示器 (≥1200px)</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>一行中如果格子数目超过12，则超出部分自动换行。</li>
<li>栅格类属性可以<strong>向上兼容</strong>。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。</li>
<li>如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。</li>
</ul>
<h2 id="4-CSS-样式和-JS-插件"><a href="#4-CSS-样式和-JS-插件" class="headerlink" title="4. CSS 样式和 JS 插件"></a>4. CSS 样式和 JS 插件</h2><h3 id="4-1-全局-CSS-样式"><a href="#4-1-全局-CSS-样式" class="headerlink" title="4.1 全局 CSS 样式"></a>4.1 全局 CSS 样式</h3><p><strong>按钮</strong>：class=”btn btn-default”</p>
<p><strong>图片</strong>：</p>
<ul>
<li>class=”img-responsive”：图片在任意尺寸都占100%。</li>
<li><p>图片形状：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">alt</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"img-rounded"</span>&gt;</span>：方形</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">alt</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"img-circle"</span>&gt;</span> ： 圆形</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">alt</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"img-thumbnail"</span>&gt;</span> ：相框</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>表格</strong></p>
<ul>
<li>table</li>
<li>table-bordered</li>
<li>table-hover</li>
</ul>
<p><strong>表单</strong></p>
<ul>
<li>给表单项添加：class=”form-control” </li>
</ul>
<h3 id="4-2-组件"><a href="#4-2-组件" class="headerlink" title="4.2 组件"></a><strong>4.2 组件</strong></h3><ul>
<li>导航条</li>
<li>分页条</li>
</ul>
<h3 id="4-3-插件"><a href="#4-3-插件" class="headerlink" title="4.3 插件"></a><strong>4.3 插件</strong></h3><ul>
<li>轮播图 Carousel </li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP学习笔记</title>
    <url>/Java/JavaWeb/JSP/JSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Java Server Pages： Java 服务器端页面。</p>
<ul>
<li>可理解为：一个特殊的页面，其中既可定义html标签，又可定义 Java 代码。</li>
<li>用于<strong>简化书写</strong>。</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>JSP 本质上就是一个 <strong>Servlet</strong>。</p>
<h2 id="JSP-脚本"><a href="#JSP-脚本" class="headerlink" title="JSP 脚本"></a>JSP 脚本</h2><p>JSP 定义 Java 代码的方式：</p>
<ul>
<li>1.&lt;%  代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。</li>
<li>2.&lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。</li>
<li>3.&lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title>会话技术Cookie&amp;Session</title>
    <url>/Java/JavaWeb/HTTP/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AFCookie-Session/</url>
    <content><![CDATA[<h2 id="1-会话技术"><a href="#1-会话技术" class="headerlink" title="1.会话技术"></a>1.会话技术</h2><p><strong>会话</strong>：一次会话中包含多次请求和响应。</p>
<ul>
<li>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。</li>
</ul>
<p><strong>功能</strong>：在一次会话的范围内的多次请求间，共享数据。</p>
<p><strong>方式</strong>：</p>
<ul>
<li>客户端会话技术：<strong>Cookie</strong></li>
<li>服务器端会话技术：<strong>Session</strong></li>
</ul>
<h2 id="2-Cookie"><a href="#2-Cookie" class="headerlink" title="2.Cookie"></a>2.Cookie</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>客户端会话技术，将数据保存到客户端。</p>
<h3 id="2-2-使用步骤"><a href="#2-2-使用步骤" class="headerlink" title="2.2 使用步骤"></a>2.2 使用步骤</h3><ul>
<li><p>创建Cookie对象，绑定数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Cookie(String name, String value)</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送Cookie对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.addCookie(Cookie cookie)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取Cookie，拿到数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie[]  request.getCookies()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-3-实现原理"><a href="#2-3-实现原理" class="headerlink" title="2.3 实现原理"></a>2.3 实现原理</h3><p>基于响应头 set-cookie 和请求头 cookie 实现</p>
<h3 id="2-4-cookie-的细节"><a href="#2-4-cookie-的细节" class="headerlink" title="2.4 cookie 的细节"></a>2.4 cookie 的细节</h3><h4 id="1-一次发送多个-cookie"><a href="#1-一次发送多个-cookie" class="headerlink" title="1.一次发送多个 cookie"></a>1.一次发送多个 cookie</h4><ul>
<li>可以创建多个 Cookie 对象，使用response调用多次 addCookie 方法发送 cookie 即可。</li>
</ul>
<h4 id="2-cookie-在浏览器中保存多长时间"><a href="#2-cookie-在浏览器中保存多长时间" class="headerlink" title="2.cookie 在浏览器中保存多长时间"></a>2.cookie 在浏览器中保存多长时间</h4><ul>
<li>默认情况下，当浏览器关闭后，Cookie 数据被销毁。</li>
<li><strong>持久化存储</strong>：setMaxAge(int seconds)<ul>
<li>正数：将 Cookie 数据写到硬盘的文件中。持久化存储。并指定 cookie 存活时间，时间到后，cookie 文件自动失效。</li>
<li>负数：默认值。</li>
<li>零：删除cookie信息。</li>
</ul>
</li>
</ul>
<h4 id="3-cookie-能不能存中文"><a href="#3-cookie-能不能存中文" class="headerlink" title="3.cookie 能不能存中文"></a>3.cookie 能不能存中文</h4><ul>
<li>在 tomcat 8 之前，cookie中不能直接存储中文数据。<ul>
<li>需要将中文数据转码—-一般采用URL编码(%E3)。</li>
</ul>
</li>
<li>在 tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析。</li>
</ul>
<h4 id="4-cookie-共享问题"><a href="#4-cookie-共享问题" class="headerlink" title="4.cookie 共享问题"></a>4.cookie 共享问题</h4><ul>
<li>假设在一个 tomcat 服务器中，部署了多个 web 项目，那么在这些 web 项目中 cookie 能不能共享？<ul>
<li>默认情况下 cookie 不能共享。</li>
<li>setPath(String path)：设置 cookie 的获取范围。默认情况下，设置当前的虚拟目录。如果要共享，则可以将 path 设置为”/“。</li>
</ul>
</li>
<li>不同的 tomcat 服务器间 cookie 共享问题？<ul>
<li>setDomain(String path)：如果设置一级域名相同，那么多个服务器之间cookie可以共享。<br>setDomain(“.baidu.com”)，那么 tieba.baidu.com 和 news.baidu.com 中 cookie 可以共享。</li>
</ul>
</li>
</ul>
<h4 id="5-Cookie的特点和作用"><a href="#5-Cookie的特点和作用" class="headerlink" title="5.Cookie的特点和作用"></a>5.Cookie的特点和作用</h4><ul>
<li>特点：<ul>
<li>cookie 存储数据在客户端浏览器。</li>
<li>浏览器对于单个 cookie 的大小有限制(4kb) 以及对同一个域名下的总 cookie 数量也有限制(20个)。</li>
</ul>
</li>
<li>作用：<ul>
<li>cookie 一般用于存出少量的不太敏感的数据。</li>
<li>在不登录的情况下，完成服务器对客户端的身份识别。</li>
</ul>
</li>
</ul>
<h4 id="6-案例：记住上一次访问时间"><a href="#6-案例：记住上一次访问时间" class="headerlink" title="6.案例：记住上一次访问时间"></a>6.案例：记住上一次访问时间</h4><p><strong>需求</strong>：</p>
<ul>
<li>访问一个 Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。</li>
<li>如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串。</li>
</ul>
<p><strong>分析</strong>：</p>
<ul>
<li>可以采用 Cookie 来完成。</li>
<li>在服务器中的 Servlet 判断是否有一个名为 lastTime 的cookie：<ul>
<li>有：不是第一次访问<ul>
<li>响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20</li>
<li>写回 Cookie：lastTime=2018年6月10日11:50:01</li>
</ul>
</li>
<li>没有：是第一次访问<ul>
<li>响应数据：您好，欢迎您首次访问</li>
<li>写回 Cookie：lastTime=2018年6月10日11:50:01</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-Session"><a href="#3-Session" class="headerlink" title="3.Session"></a>3.Session</h2><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h3><p>服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p>
<h3 id="3-2-快速入门"><a href="#3-2-快速入门" class="headerlink" title="3.2 快速入门"></a>3.2 快速入门</h3><ul>
<li>1.获取 HttpSession 对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br></pre></td></tr></table></figure>
<ul>
<li>2.使用 HttpSession 对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-原理"><a href="#3-3-原理" class="headerlink" title="3.3 原理"></a>3.3 原理</h3><p>Session 的实现是依赖于 <strong>Cookie</strong> 的。</p>
<h3 id="3-4-细节"><a href="#3-4-细节" class="headerlink" title="3.4 细节"></a>3.4 细节</h3><ul>
<li>当客户端关闭后，服务器不关闭，两次获取 session 是否为同一个？<ul>
<li>默认情况下不是。</li>
<li>如果需要相同，则可以创建 Cookie，键为 JSESSIONID，设置最大存活时间，让 cookie 持久化保存。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie c = <span class="keyword">new</span> Cookie(<span class="string">"JSESSIONID"</span>,session.getId());</span><br><span class="line">c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">response.addCookie(c);</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端不关闭，服务器关闭后，两次获取的 session 是同一个吗？<ul>
<li>不是同一个，但是要确保数据不丢失。Tomcat 自动完成以下工作：<ul>
<li>session 的钝化：在服务器正常关闭之前，将 session 对象系列化到硬盘上。</li>
<li>session 的活化：在服务器启动后，将 session 文件转化为内存中的 session 对象即可。</li>
</ul>
</li>
</ul>
</li>
<li>session 什么时候被销毁？<ul>
<li>服务器关闭.</li>
<li>session 对象调用 invalidate() 。</li>
<li>session 默认失效时间 30分钟。<ul>
<li>选择性配置修改</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-Session-的特点"><a href="#3-5-Session-的特点" class="headerlink" title="3.5 Session 的特点"></a>3.5 Session 的特点</h3><ul>
<li>session 用于存储一次会话的多次请求的数据，存在服务器端。</li>
<li>session 可以存储任意类型，任意大小的数据。</li>
</ul>
<h2 id="4-Session-与-Cookie-的区别"><a href="#4-Session-与-Cookie-的区别" class="headerlink" title="4.Session 与 Cookie 的区别"></a>4.Session 与 Cookie 的区别</h2><ul>
<li>session 存储数据在服务器端，Cookie 在客户端。</li>
<li>session没有数据大小限制，Cookie有。</li>
<li>session数据安全，Cookie相对于不安全。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>HTTP</tag>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring JDBC</title>
    <url>/Java/%E6%95%B0%E6%8D%AE%E5%BA%93/Spring-JDBC/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>Spring</strong> 框架对 JDBC 的简单封装，提供了一个 JDBCTemplate 对象简化 JDBC 的开发。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h4 id="1-导入-jar-包。"><a href="#1-导入-jar-包。" class="headerlink" title="1.导入 jar 包。"></a>1.导入 jar 包。</h4><h4 id="2-创建-JdbcTemplate-对象。依赖于数据源DataSource"><a href="#2-创建-JdbcTemplate-对象。依赖于数据源DataSource" class="headerlink" title="2.创建 JdbcTemplate 对象。依赖于数据源DataSource"></a>2.创建 JdbcTemplate 对象。依赖于数据源DataSource</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(ds);</span><br></pre></td></tr></table></figure>
<h4 id="3-调用JdbcTemplate的方法来完成CRUD的操作。"><a href="#3-调用JdbcTemplate的方法来完成CRUD的操作。" class="headerlink" title="3.调用JdbcTemplate的方法来完成CRUD的操作。"></a>3.调用JdbcTemplate的方法来完成CRUD的操作。</h4><ul>
<li>update()：执行DML语句。增、删、改语句。</li>
<li>queryForMap()：查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合。<ul>
<li>注意：这个方法查询的结果集长度只能是1。</li>
</ul>
</li>
<li>queryForList()：查询结果将结果集封装为list集合。<ul>
<li>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中。</li>
</ul>
</li>
<li>query()：查询结果，将结果封装为JavaBean对象。<ul>
<li>query的参数：RowMapper<ul>
<li>一般使用BeanPropertyRowMapper实现类，可以完成数据到JavaBean的自动封装。</li>
<li>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</li>
</ul>
</li>
</ul>
</li>
<li>queryForObject：查询结果，将结果封装为对象。<ul>
<li>一般用于聚合函数的查询。</li>
</ul>
</li>
</ul>
<h4 id="4-示例"><a href="#4-示例" class="headerlink" title="4.示例"></a>4.示例</h4><p>需求：</p>
<ul>
<li>修改1号数据的 salary 为 10000。</li>
<li>添加一条记录。</li>
<li>删除刚才添加的记录。</li>
<li>查询id为1的记录，将其封装为Map集合。</li>
<li>查询所有记录，将其封装为List。</li>
<li>查询所有记录，将其封装为<a href="https://gitee.com/TommyMerlin/code-host/blob/master/Java/Emp.java" target="_blank" rel="noopener">Emp对象</a>的List集。</li>
<li>查询总记录数。</li>
</ul>
<p>数据表：</p>
<p><img src="/Java/数据库/Spring-JDBC/表.png" alt="表" style="zoom:90%;"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取JDBCTemplate对象</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 修改1号数据的 salary 为 10000</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义sql</span></span><br><span class="line">    String sql = <span class="string">"update emp set salary = 10000 where id = 1001"</span>;</span><br><span class="line">    <span class="comment">//执行sql</span></span><br><span class="line">    <span class="keyword">int</span> count = template.update(sql);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. 添加一条记录</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"insert into emp(id,ename,dept_id) values(?,?,?)"</span>;</span><br><span class="line">    <span class="keyword">int</span> count = template.update(sql, <span class="number">1015</span>, <span class="string">"郭靖"</span>, <span class="number">10</span>);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.删除刚才添加的记录</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"delete from emp where id = ?"</span>;</span><br><span class="line">    <span class="keyword">int</span> count = template.update(sql, <span class="number">1015</span>);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4.查询id为1001的记录，将其封装为Map集合</span></span><br><span class="line"><span class="comment">//注意：这个方法查询的结果集长度只能是1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"select * from emp where id = ?"</span>;</span><br><span class="line">    Map&lt;String, Object&gt; map = template.queryForMap(sql, <span class="number">1001</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    <span class="comment">//查询结果：&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5. 查询所有记录，将其封装为List</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);</span><br><span class="line">    <span class="keyword">for</span> (Map&lt;String, Object&gt; stringObjectMap : list) 			           			         	System.out.println(stringObjectMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6. 查询所有记录，将其封装为Emp对象的List集合--&gt;手动实现RowMapper接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">	List&lt;Emp&gt; list = template.query(sql, <span class="keyword">new</span> RowMapper&lt;Emp&gt;() &#123;</span><br><span class="line">			</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Emp <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            Emp emp = <span class="keyword">new</span> Emp();</span><br><span class="line">            <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">            String ename = rs.getString(<span class="string">"ename"</span>);</span><br><span class="line">            <span class="keyword">int</span> job_id = rs.getInt(<span class="string">"job_id"</span>);</span><br><span class="line">            <span class="keyword">int</span> mgr = rs.getInt(<span class="string">"mgr"</span>);</span><br><span class="line">            Date joindate = rs.getDate(<span class="string">"joindate"</span>);</span><br><span class="line">            <span class="keyword">double</span> salary = rs.getDouble(<span class="string">"salary"</span>);</span><br><span class="line">            <span class="keyword">double</span> bonus = rs.getDouble(<span class="string">"bonus"</span>);</span><br><span class="line">            <span class="keyword">int</span> dept_id = rs.getInt(<span class="string">"dept_id"</span>);</span><br><span class="line">			</span><br><span class="line">            emp.setId(id);</span><br><span class="line">            emp.setEname(ename);</span><br><span class="line">            emp.setJob_id(job_id);</span><br><span class="line">            emp.setMgr(mgr);</span><br><span class="line">            emp.setJoindate(joindate);</span><br><span class="line">            emp.setSalary(salary);</span><br><span class="line">            emp.setBonus(bonus);</span><br><span class="line">            emp.setDept_id(dept_id);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> emp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">		System.out.println(emp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重点掌握</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6. 查询所有记录，将其封装为Emp对象的List集合--&gt;自动封装emp对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">	List&lt;Emp&gt; list = template.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));</span><br><span class="line">	<span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">		System.out.println(emp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7. 查询总记录数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"select count(id) from emp"</span>;</span><br><span class="line">    Long total = template.queryForObject(sql, Long.class);</span><br><span class="line">    System.out.println(total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="注解的基本原理"><a href="#注解的基本原理" class="headerlink" title="注解的基本原理"></a><strong>注解的基本原理</strong></h2><p>意如其名，其本来的意思就是用来做<strong>标注</strong>用：可以在<strong>类</strong>、<strong>字段变量</strong>、<strong>方法</strong>、<strong>接口</strong>等位置进行一个<strong>特殊的标记</strong>，为后续做一些诸如：<strong>代码生成</strong>、<strong>数据校验</strong>、<strong>资源整合</strong>等工作做铺垫。</p>
<p>注解一旦对代码标注完成，后续我们就可以结合Java强大的<strong>反射机制</strong>，在运行时动态地获取到注解的标注信息，从而可以执行很多其他逻辑，完成我们想要的自动化工作。</p>
<hr>
<h2 id="造一个注解"><a href="#造一个注解" class="headerlink" title="造一个注解"></a>造一个注解</h2><p><code>Spring</code>自身提供了非常多好用的注解可以用来方便地帮我们做数据校验的工作。</p>
<p>比如，在没有注解加持时，我们想要校验 <code>Student</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> Long id;        <span class="comment">// 学号    </span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 姓名    </span></span><br><span class="line">    <span class="keyword">private</span> String mobile;  <span class="comment">// 手机号码(11位)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只能通过手写 <code>if</code>判断来进行校验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStudent</span><span class="params">( @RequestBody Student student )</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( student == <span class="keyword">null</span> )        </span><br><span class="line">    	<span class="keyword">return</span> <span class="string">"传入的Student对象为null，请传值"</span>;    </span><br><span class="line">    <span class="keyword">if</span>( student.getName()==<span class="keyword">null</span> || <span class="string">""</span>.equals(student.getName()) )        </span><br><span class="line">    	<span class="keyword">return</span> <span class="string">"传入的学生姓名为空，请传值"</span>;    </span><br><span class="line">    <span class="keyword">if</span>( student.getScore()==<span class="keyword">null</span> )        </span><br><span class="line">    	<span class="keyword">return</span> <span class="string">"传入的学生成绩为null，请传值"</span>;    </span><br><span class="line">    <span class="keyword">if</span>( (student.getScore()&lt;<span class="number">0</span>) || (student.getScore()&gt;<span class="number">100</span>) )        </span><br><span class="line">    	<span class="keyword">return</span> <span class="string">"传入的学生成绩有误，分数应该在0~100之间"</span>;    </span><br><span class="line">    <span class="keyword">if</span>( student.getMobile()==<span class="keyword">null</span> || <span class="string">""</span>.equals(student.getMobile()) )        </span><br><span class="line">    	<span class="keyword">return</span> <span class="string">"传入的学生电话号码为空，请传值"</span>;    </span><br><span class="line">    <span class="keyword">if</span>( student.getMobile().length()!=<span class="number">11</span> )        </span><br><span class="line">    	<span class="keyword">return</span> <span class="string">"传入的学生电话号码长度有误，应为11位"</span>;</span><br><span class="line">    </span><br><span class="line">    studentService.addStudent( student ); <span class="comment">// 将student对象存入MySQL数据库    </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"SUCCESS"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式非常繁琐！</p>
<p>但是借助于 <code>Spring</code> 提供的注解，数据校验工作可以变得非常优雅：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"传入的姓名为null，请传值"</span>)    </span><br><span class="line">    <span class="meta">@NotEmpty</span>(message = <span class="string">"传入的姓名为空字符串，请传值"</span>)    </span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 姓名</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"传入的分数为null，请传值"</span>)    </span><br><span class="line">    <span class="meta">@Min</span>(value = <span class="number">0</span>,message = <span class="string">"传入的学生成绩有误，分数应该在0~100之间"</span>)    </span><br><span class="line">    <span class="meta">@Max</span>(value = <span class="number">100</span>,message = <span class="string">"传入的学生成绩有误，分数应该在0~100之间"</span>)    </span><br><span class="line">    <span class="keyword">private</span> Integer score;  <span class="comment">// 分数</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"传入的电话为null，请传值"</span>)    </span><br><span class="line">    <span class="meta">@NotEmpty</span>(message = <span class="string">"传入的电话为空字符串，请传值"</span>)    </span><br><span class="line">    <span class="meta">@Length</span>(min = <span class="number">11</span>, max = <span class="number">11</span>, message = <span class="string">"传入的电话号码长度有误，必须为11位"</span>)    </span><br><span class="line">    <span class="keyword">private</span> String mobile;  <span class="comment">// 电话号码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上文的 <code>@Length</code>注解为例，自己动手实现一遍，这个学会了，其他注解实现原理也是类似。</p>
<p><img src="/Java/基础知识/注解/640.jpg" alt="640" style="zoom:60%;"></p>
<p>总共分三大步实现。</p>
<h3 id="第一步：首先定义注解：-Length"><a href="#第一步：首先定义注解：-Length" class="headerlink" title="第一步：首先定义注解：@Length"></a><strong>第一步：首先定义注解：@Length</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Length &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>;          <span class="comment">// 允许字符串长度的最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>;          <span class="comment">// 允许字符串长度的最大值</span></span><br><span class="line">    <span class="function">String <span class="title">errorMsg</span><span class="params">()</span></span>;  <span class="comment">// 自定义的错误提示信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几点说明：</p>
<p>1、注解的定义有点像定义接口 <code>interface</code>，但唯一不同的是前面需要加一个 <code>@</code>符号。</p>
<p>2、注解的成员变量只能使用基本类型、 <code>String</code>或者 <code>enum</code>枚举，比如 <code>int</code>可以，但 <code>Integer</code>这种包装类型就不行，需注意。</p>
<p>3、像上面 <code>@Target</code>、 <code>@Retention</code>这种加在注解定义上面的注解，我们称为 <strong>“元注解”</strong>，元注解就是专门用于给注解添加注解的注解，元注解就是天生就有的注解，可直接用于注解的定义上。</p>
<p>4、 <code>@Target(xxx)</code> 用来说明该自定义注解可以用在什么位置，比如：</p>
<ul>
<li><code>ElementType.FIELD</code>：说明自定义的注解可以用于类的变量</li>
<li><code>ElementType.METHOD</code>：说明自定义的注解可以用于类的方法</li>
<li><code>ElementType.TYPE</code>：说明自定义的注解可以用于类本身、接口或 <code>enum</code>类型</li>
<li>等等… 还有很多，如果记不住，建议现用现查</li>
</ul>
<p>5、 <code>@Retention(xxx)</code> 用来说明你自定义注解的生命周期，比如：</p>
<ul>
<li><code>@Retention(RetentionPolicy.RUNTIME)</code>：表示注解可以一直保留到运行时，因此可以通过反射获取注解信息</li>
<li><code>@Retention(RetentionPolicy.CLASS)</code>：表示注解被编译器编译进 <code>class</code>文件，但运行时会忽略</li>
<li><code>@Retention(RetentionPolicy.SOURCE)</code>：表示注解仅在源文件中有效，编译时就会被忽略</li>
</ul>
<p>所以声明周期从长到短分别为：<strong>RUNTIME</strong> &gt; <strong>CLASS</strong> &gt; <strong>SOURCE</strong> ，一般来说，如果需要在运行时去动态获取注解的信息，还是得用RUNTIME，就像本文所用。</p>
<h3 id="第二步：获取注解并对其进行验证"><a href="#第二步：获取注解并对其进行验证" class="headerlink" title="第二步：获取注解并对其进行验证"></a><strong>第二步：获取注解并对其进行验证</strong></h3><p>在运行时想获取注解所代包含的信息，该怎么办？那当然得用 <strong>Java的反射相关知识</strong>！</p>
<p>下面写了一个验证函数 <code>validate()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">validate</span><span class="params">( Object object )</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先通过反射获取object对象的类有哪些字段    </span></span><br><span class="line">    <span class="comment">// 对本文来说就可以获取到Student类的id、name、mobile三个字段    </span></span><br><span class="line">    Field[] fields = object.getClass().getDeclaredFields();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for循环逐个字段校验，看哪个字段上标了注解    </span></span><br><span class="line">    <span class="keyword">for</span>( Field field : fields ) &#123;</span><br><span class="line">    	<span class="comment">// if判断：检查该字段上有没有标注了@Length注解        </span></span><br><span class="line">    	<span class="keyword">if</span>( field.isAnnotationPresent(Length.class) ) &#123;            </span><br><span class="line">    		<span class="comment">// 通过反射获取到该字段上标注的@Length注解的详细信息            </span></span><br><span class="line">    		Length length = field.getAnnotation( Length.class );            </span><br><span class="line">    		field.setAccessible( <span class="keyword">true</span> ); <span class="comment">// 让我们在反射时能访问到私有变量           </span></span><br><span class="line">    		<span class="comment">// 用过反射获取字段的实际值            </span></span><br><span class="line">    		<span class="keyword">int</span> value =( (String)field.get(object) ).length();            </span><br><span class="line">    		<span class="comment">// 将字段的实际值和注解上做标示的值进行比对            </span></span><br><span class="line">    		<span class="keyword">if</span>( value&lt;length.min() || value&gt;length.max() ) &#123;                </span><br><span class="line">    			<span class="keyword">return</span> length.errorMsg();            </span><br><span class="line">    		&#125;        </span><br><span class="line">    	&#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三步：使用注解"><a href="#第三步：使用注解" class="headerlink" title="第三步：使用注解"></a><strong>第三步：使用注解</strong></h3><p>这一步比较轻松，使用注解的过程往往都是很愉悦的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long id;        <span class="comment">// 学号</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 姓名</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Length</span>(min = <span class="number">11</span>, max = <span class="number">11</span>, errorMsg = <span class="string">"电话号码的长度必须为11位"</span>)    </span><br><span class="line">    <span class="keyword">private</span> String mobile;  <span class="comment">// 手机号码(11位)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&amp;mid=2247485261&amp;idx=1&amp;sn=aa8ba3e8f1de124067e87115635302c5&amp;chksm=fdded189caa9589f48ab4164116665480e2232141c307fb3a8625312e1a06f6bbf8567113175&amp;scene=0&amp;xtrack=1&amp;key=4f115a90f0767c08547738b5e2d2cf43683cc797ae0c99baf708937ded5dcab97ef53f7f0f83e5b3f1dd40e6b9a7e8f2e27b9c2c2edb51601454ab8fb7cd137d5b86d511e17d7679c74be5e6348f46a8&amp;ascene=14&amp;uin=OTM5MzQ5Njgx&amp;devicetype=Windows+10&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=AYnDESjqgxG0ydMjUMfrM60%3D&amp;pass_ticket=cySe8rjRH%2Buu%2BpDboKyjbWa6XhAXVmVNUL5ebLAJYqqp%2FjFlzAEOVIiplI%2FD7WG9" target="_blank" rel="noopener">转载来源</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库连接池</title>
    <url>/Java/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1概念"><a href="#1-1概念" class="headerlink" title="1.1概念"></a><strong>1.1概念</strong></h3><p>一个容器(集合)，存放数据库连接的容器。<br>        当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p>
<h3 id="1-2好处"><a href="#1-2好处" class="headerlink" title="1.2好处"></a><strong>1.2好处</strong></h3><ul>
<li>节约资源</li>
<li>用户访问高效</li>
</ul>
<h3 id="1-3实现"><a href="#1-3实现" class="headerlink" title="1.3实现"></a><strong>1.3实现</strong></h3><ul>
<li>1.标准接口：DataSource   javax.sql包下。<ul>
<li>获取连接：getConnection()</li>
<li>归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</li>
</ul>
</li>
<li>2.数据库厂商实现<ul>
<li>C3P0：数据库连接池技术。</li>
<li>Druid：数据库连接池实现技术，由阿里巴巴提供。</li>
</ul>
</li>
</ul>
<h3 id="1-4-C3P0：数据库连接池技术"><a href="#1-4-C3P0：数据库连接池技术" class="headerlink" title="1.4 C3P0：数据库连接池技术"></a>1.4 C3P0：数据库连接池技术</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li><p>1.导入jar包 (两个) c3p0-0.9.5.2.jar  mchange-commons-java-0.2.12.jar ，</p>
<ul>
<li>不要忘记导入数据库驱动 jar 包。</li>
</ul>
</li>
</ul>
<ol>
<li><p>2.定义配置文件：</p>
<ul>
<li>名称： c3p0.properties 或 c3p0-config.xml</li>
<li>路径：直接将文件放在 <code>src</code> 目录下即可。</li>
</ul>
</li>
</ol>
<ul>
<li><p>3.创建核心对象：数据库连接池对象ComboPooledDataSource。</p>
</li>
<li><p>4.获取连接： getConnection()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建数据库连接池对象</span></span><br><span class="line">DataSource ds  = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"><span class="comment">//2. 获取连接对象</span></span><br><span class="line">Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><p>C3P0配置文件 <code>c3p0-config.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用默认的配置读取连接池对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--  连接参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span>&gt;</span>jdbc:mysql:///test01?useUnicode=true&amp;amp;useJDBCCompliantTimezoneShift=true&amp;amp;useLegacyDatetimeCode=false&amp;amp;serverTimezone=UTC<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">"otherc3p0"</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--  连接参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span>&gt;</span>jdbc:mysql://localhost:3306/jdbc1?characterEncoding=utf-8&amp;amp;useSSL=true&amp;amp;serverTimezone=GMT<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>zjuhuye<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>8<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>类代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C3P0Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        DataSource ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        Connection conn = ds.getConnection();</span><br><span class="line">        System.out.println(conn);</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-Druid：数据库连接池实现技术"><a href="#1-5-Druid：数据库连接池实现技术" class="headerlink" title="1.5 Druid：数据库连接池实现技术"></a>1.5 Druid：数据库连接池实现技术</h3><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>1.导入 jar 包 druid-1.0.9.jar</li>
<li>2.定义配置文件：<ul>
<li>properties 形式</li>
<li>可以叫任意名称，可以放在任意目录下</li>
</ul>
</li>
<li>3.加载配置文件。Properties</li>
<li>4.获取数据库连接池对象：通过工厂类来获取  DruidDataSourceFactory</li>
<li>5.获取连接：getConnection()</li>
</ul>
<p><strong>配置文件</strong> <code>druid.properties</code>：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql:///test01?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"># 初始化连接数</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 最大等待时间</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">    InputStream is = DruidDemo1.class.getClassLoader().getResourceAsStream(<span class="string">"druid.properties"</span>);</span><br><span class="line">    pro.load(is);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接池对象</span></span><br><span class="line">    DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    Connection conn = ds.getConnection();</span><br><span class="line">    System.out.println(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义工具类"><a href="#定义工具类" class="headerlink" title="定义工具类"></a>定义工具类</h4><p>1.定义一个工具类 <code>JDBCUtils</code>。</p>
<p>2.提供静态代码块加载配置文件，初始化连接池对象。</p>
<p>3.提供方法</p>
<ul>
<li>提供连接方法：通过数据库连接池获取连接。</li>
<li>释放资源。</li>
<li>获取连接池的方法。</li>
</ul>
<p><strong><a href="https://gitee.com/TommyMerlin/code-host/blob/master/Java/JDBCUtils.java#" target="_blank" rel="noopener">代码</a></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HuYe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/2/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Druid 连接池工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.定义成员变量 DataSource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.加载配置文件</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            pro.load(JDBCUtils.class.getClassLoader().</span><br><span class="line">                     getResourceAsStream(<span class="string">"druid.properties"</span>));</span><br><span class="line">            <span class="comment">//3.获取DataSource</span></span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连接对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt SQL执行语句</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn 连接对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt, Connection conn)</span> </span>&#123;</span><br><span class="line">        close(<span class="keyword">null</span>, stmt, conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rs   ResultSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt SQL执行语句</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn 连接对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs, Statement stmt, Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//归还连接</span></span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连接池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用工具类代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成添加操作，给 stuinfo 表添加一条记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取连接</span></span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        <span class="comment">//2.定义sql</span></span><br><span class="line">        String sql = <span class="string">"insert into stuinfo values(?,?)"</span>;</span><br><span class="line">        <span class="comment">//3.获取pstmt对象</span></span><br><span class="line">        pstmt = conn.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//4.给参数赋值</span></span><br><span class="line">        pstmt.setInt(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        pstmt.setString(<span class="number">2</span>, <span class="string">"ZJU"</span>);</span><br><span class="line">        <span class="comment">//5.执行sql</span></span><br><span class="line">        <span class="comment">//executeUpdate--&gt; INSERT,UPDATE,DELETE</span></span><br><span class="line">        <span class="comment">//executeQuery --&gt; SELECT</span></span><br><span class="line">        <span class="keyword">int</span> count = pstmt.executeUpdate();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//6.释放资源</span></span><br><span class="line">        JDBCUtils.close(pstmt, conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP学习笔记</title>
    <url>/Java/JavaWeb/HTTP/HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><strong>概念</strong>：Hyper Text Transfer Protocol 超文本传输协议。</p>
<p><strong>传输协议</strong>：定义了客户端和服务器端通信时，发送数据的格式。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>基于 TCP/IP 的高级协议。</li>
<li>默认端口号：80。</li>
<li>基于请求/响应模型：一次请求对应一次响应。</li>
<li>无状态：每次请求之间相互独立，不能交互数据。</li>
</ul>
<p><strong>历史版本</strong>：</p>
<ul>
<li>1.0：每一次请求响应都会建立新的连接。</li>
<li>1.1：复用连接。</li>
</ul>
<h2 id="2-请求消息数据格式"><a href="#2-请求消息数据格式" class="headerlink" title="2.请求消息数据格式"></a>2.请求消息数据格式</h2><h3 id="2-1-请求行"><a href="#2-1-请求行" class="headerlink" title="2.1 请求行"></a>2.1 <strong>请求行</strong></h3><ul>
<li>格式：请求方式 请求url 请求协议/版本</li>
<li>请求方式：7中，常用2种：<ul>
<li>GET：<ul>
<li>请求参数在请求行中，在url后。</li>
<li>请求的url长度有限制。</li>
<li>不太安全。</li>
</ul>
</li>
<li>POST：<ul>
<li>请求参数在请求体中。</li>
<li>请求的url长度没有限制。</li>
<li>相对安全。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-请求头"><a href="#2-2-请求头" class="headerlink" title="2.2 请求头"></a>2.2 <strong>请求头</strong></h3><ul>
<li>格式：请求头名称：请求头值</li>
<li>常见请求头：<ul>
<li>User-Agent：告诉服务器访问所使用的浏览器版本信息，解决浏览器兼容性问题。</li>
<li>Referer：告诉服务器请求来源。<ul>
<li>防盗链</li>
<li>统计工作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-请求空行"><a href="#2-3-请求空行" class="headerlink" title="2.3 请求空行"></a>2.3 <strong>请求空行</strong></h3><ul>
<li>空行，用于分割POST请求的请求头和请求体。</li>
</ul>
<h3 id="2-4-请求体（正文）"><a href="#2-4-请求体（正文）" class="headerlink" title="2.4 请求体（正文）"></a>2.4 <strong>请求体（正文）</strong></h3><ul>
<li>封装POST请求消息的请求参数。</li>
</ul>
<p>字符串格式：</p>
<blockquote>
<p>GET /login.html HTTP/1.1<br>Host: localhost:8080<br>Connection: keep-alive<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36 Sec-Fetch-Dest: document<br>Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3;q=0.9<br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q=0.9,en;q=0.8<br>Referer: <a href="http://localhost/login.html" target="_blank" rel="noopener">http://localhost/login.html</a></p>
</blockquote>
<h2 id="3-Request对象"><a href="#3-Request对象" class="headerlink" title="3.Request对象"></a>3.Request对象</h2><h3 id="3-1-request-继承体系结构"><a href="#3-1-request-继承体系结构" class="headerlink" title="3.1 request 继承体系结构"></a>3.1 request 继承体系结构</h3><ul>
<li>ServletRequest(接口) &lt;— HttpServletRequest(接口) —org.apache.catalina.connector.RequestFacade 类(tomcat)</li>
</ul>
<h3 id="3-2-request-功能"><a href="#3-2-request-功能" class="headerlink" title="3.2 request 功能"></a>3.2 request 功能</h3><h4 id="3-2-1-获取请求消息数据"><a href="#3-2-1-获取请求消息数据" class="headerlink" title="3.2.1.获取请求消息数据"></a>3.2.1.获取请求消息数据</h4><h5 id="获取请求行数据"><a href="#获取请求行数据" class="headerlink" title="获取请求行数据"></a>获取<strong>请求行</strong>数据</h5><ul>
<li>GET /demo/show？name=zhangsan HTTP/1.1</li>
<li>方法：<ul>
<li>获取请求方式：GET<ul>
<li>String getMethod()</li>
</ul>
</li>
<li><strong>获取虚拟目录</strong>：/demo<ul>
<li>String getContextPath()</li>
</ul>
</li>
<li>获取 Servlet 路径 /show<ul>
<li>String getServletPath()</li>
</ul>
</li>
<li>获取 get 方式请求参数：name=zhangsan<ul>
<li>String getQueryString()</li>
</ul>
</li>
<li><strong>获取请求URI</strong>：/demo/show<ul>
<li>String getRequestURI()：/demo/show</li>
<li>StringBuffer getRequestURL()：<a href="http://localhost/demo/show" target="_blank" rel="noopener">http://localhost/demo/show</a></li>
<li>URI：统一资源标识符。</li>
<li>URL:统一资源定位符。</li>
</ul>
</li>
<li>获取版本及协议：HTTP/1.1。<ul>
<li>String getProtocol()</li>
</ul>
</li>
<li>获取客户机的IP地址。<ul>
<li>String getRemoteAddr()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="获取请求头数据"><a href="#获取请求头数据" class="headerlink" title="获取请求头数据"></a>获取<strong>请求头</strong>数据</h5><ul>
<li><strong>String getHeader(String name)</strong>：通过请求头的名称获取请求头的值。</li>
<li>Enumeration<string> getHeaderNames()：获取所有的请求头名称。</string></li>
</ul>
<p><img src="/Java/JavaWeb/HTTP/HTTP学习笔记/获取请求头.png" alt="获取请求头" style="zoom:70%;"></p>
<h5 id="获取请求体数据"><a href="#获取请求体数据" class="headerlink" title="获取请求体数据"></a>获取<strong>请求体</strong>数据</h5><ul>
<li>1.获取流对象。<ul>
<li>BufferedReader getReader()：获取字符输入流，只能操作字符数据。</li>
<li>ServletInputStream getInputStream()：获取字节输入流，可操作所有类型数据。</li>
</ul>
</li>
<li>2.从流对象中获取数据。</li>
</ul>
<h4 id="3-2-2-其他功能"><a href="#3-2-2-其他功能" class="headerlink" title="3.2.2 其他功能"></a>3.2.2 其他功能</h4><h5 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h5><ul>
<li>通用方式：get 和 post 请求都可以用。</li>
<li>String getParameter(String name)：根据参数名称获取参数值    username=zs&amp;password=123</li>
<li>String[] getParameterValues(String name)：根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game</li>
<li>Enumeration<string> getParameterNames()：获取所有请求的参数名称</string></li>
<li>Map<string,string[]> getParameterMap():获取所有参数的map集合</string,string[]></li>
</ul>
<h5 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h5><ul>
<li>一种在服务器内部的资源跳转方式。</li>
<li>步骤：<ul>
<li>1.通过request对象获取请求转发器对象：<br>  RequestDispatcher getRequestDispatcher(String path)</li>
<li>2.使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) </li>
</ul>
</li>
<li>特点：<ul>
<li>浏览器地址栏路径不发生变化。</li>
<li>只能转发到当前服务器内部资源中。</li>
<li>请求转发只是一次请求。</li>
</ul>
</li>
</ul>
<h5 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h5><ul>
<li>域对象：一个有作用范围的对象，可以在范围内共享数据。</li>
<li>request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据。</li>
<li>方法：<ul>
<li>void setAttribute(String name,Object obj)：存储数据。</li>
<li>Object getAttitude(String name)：通过键获取值。</li>
<li>void removeAttribute(String name)：通过键移除键值对。</li>
</ul>
</li>
</ul>
<h5 id="获取-ServletContext"><a href="#获取-ServletContext" class="headerlink" title="获取 ServletContext"></a>获取 ServletContext</h5><ul>
<li>ServletContext getServletContext()</li>
</ul>
<h3 id="3-3-案例：用户登录"><a href="#3-3-案例：用户登录" class="headerlink" title="3.3 案例：用户登录"></a>3.3 案例：用户登录</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a><strong>需求</strong></h4><ul>
<li>1.编写 <code>login.html</code> 登录页面。<br>username &amp; password 两个输入框</li>
<li>2.使用 Druid 数据库连接池技术,操作 mysql ，test01数据库中 stuinfo 表。</li>
<li>3.使用 JdbcTemplate 技术封装 JDBC。</li>
<li>4.登录成功跳转到 SuccessServlet 展示：登录成功！用户名,欢迎您。</li>
<li>5.登录失败跳转到 FailServlet 展示：登录失败，用户名或密码错误。</li>
</ul>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a><strong>案例分析</strong></h4><p><img src="/Java/JavaWeb/HTTP/HTTP学习笔记/登录案例分析.bmp" alt="登录案例分析" style="zoom:60%;"></p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><strong>步骤</strong></h4><ul>
<li>1.编写 <strong><a href="https://gitee.com/TommyMerlin/code-host/blob/master/Java/LoginTest/web/login.html" target="_blank" rel="noopener">login.html</a></strong> 登陆页面。</li>
<li><p>2.创建数据库环境。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> test01;</span><br><span class="line"><span class="keyword">USE</span> test01;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuinfo(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">    username <span class="built_in">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">PASSWORD</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.创建实体类 <strong><a href="https://gitee.com/TommyMerlin/code-host/blob/master/Java/LoginTest/src/com/coderhuye/domain/User.java" target="_blank" rel="noopener">User</a></strong>。</p>
</li>
<li>4.编写工具类 <strong><a href="https://gitee.com/TommyMerlin/code-host/blob/master/Java/LoginTest/src/com/coderhuye/util/JDBCUtils.java" target="_blank" rel="noopener">JDBCUtils</a></strong>。</li>
<li>5.创建包 <code>com.coderhuye.dao</code> ，创建类 <strong><a href="https://gitee.com/TommyMerlin/code-host/blob/master/Java/LoginTest/src/com/coderhuye/dao/UserDao.java" target="_blank" rel="noopener">UserDao</a></strong>,提供 login 方法。</li>
<li>6.编写 <strong><a href="https://gitee.com/TommyMerlin/code-host/blob/master/Java/LoginTest/src/com/coderhuye/web/servlet/LoginServlet.java" target="_blank" rel="noopener">LoginServlet</a></strong> 类。</li>
<li>7.编写 <strong><a href="https://gitee.com/TommyMerlin/code-host/blob/master/Java/LoginTest/src/com/coderhuye/web/servlet/FailServlet.java" target="_blank" rel="noopener">FailServlet</a></strong> 和 <strong><a href="https://gitee.com/TommyMerlin/code-host/blob/master/Java/LoginTest/src/com/coderhuye/web/servlet/SuccessServlet.java" target="_blank" rel="noopener">SuccessServlet</a></strong> 类。</li>
<li>8.login.html 中 form 表单的 action 路径的写法。<ul>
<li>虚拟目录+Servlet的资源路径</li>
</ul>
</li>
<li>9.BeanUtils工具类，简化数据封装。<ul>
<li>commons-beanutils-1.8.0.jar</li>
<li><a href="https://gitee.com/TommyMerlin/code-host/blob/master/Java/LoginServlet.java" target="_blank" rel="noopener">使用代码</a></li>
<li>1.JavaBean：标准的Java类<ul>
<li>要求：<ul>
<li>1.类必须被public修饰。</li>
<li>2.必须提供空参的构造器。</li>
<li>3.成员变量必须使用private修饰。</li>
<li>4.提供公共setter和getter方法。</li>
</ul>
</li>
<li>功能：封装数据。</li>
</ul>
</li>
<li>2.方法：<ul>
<li>setProperty()</li>
<li>getProperty()</li>
<li>populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-响应消息数据格式"><a href="#4-响应消息数据格式" class="headerlink" title="4.响应消息数据格式"></a>4.响应消息数据格式</h2><h3 id="4-1-响应行"><a href="#4-1-响应行" class="headerlink" title="4.1 响应行"></a>4.1 响应行</h3><ul>
<li>组成：协议/版本 响应状态码 状态码描述</li>
<li>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。</li>
</ul>
<p><img src="/Java/JavaWeb/HTTP/HTTP学习笔记/状态码.png" alt="状态码" style="zoom:60%;"></p>
<h3 id="4-2-响应头"><a href="#4-2-响应头" class="headerlink" title="4.2 响应头"></a>4.2 响应头</h3><ul>
<li>格式：    头名称： 值</li>
<li>常见的响应头：<ul>
<li>Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式。</li>
<li>Content-disposition：服务器告诉客户端以什么格式打开响应体数据。<ul>
<li>in-line：默认值，在当前页面内打开。</li>
<li>attachment;filename=xxx：以附件形式打开响应体，文件下载</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-3-响应空行"><a href="#4-3-响应空行" class="headerlink" title="4.3 响应空行"></a>4.3 响应空行</h3><h3 id="4-4-响应体"><a href="#4-4-响应体" class="headerlink" title="4.4 响应体"></a>4.4 响应体</h3><ul>
<li>传输的数据</li>
</ul>
<h3 id="响应字符串格式"><a href="#响应字符串格式" class="headerlink" title="响应字符串格式"></a>响应字符串格式</h3><blockquote>
<p>HTTP/1.1 200 OK<br>Content-Type: text/html;charset=UTF-8<br>Content-Length: 101<br>Date: Wed, 06 Jun 2018 07:08:42 GMT</p>
</blockquote>
<h2 id="5-Response对象"><a href="#5-Response对象" class="headerlink" title="5.Response对象"></a>5.Response对象</h2><h3 id="5-1-功能"><a href="#5-1-功能" class="headerlink" title="5.1 功能"></a>5.1 功能</h3><h4 id="设置响应消息"><a href="#设置响应消息" class="headerlink" title="设置响应消息"></a>设置响应消息</h4><ul>
<li>设置响应行<ul>
<li>格式：HTTP/1.1 200 ok</li>
<li>设置状态码：setStatus(int sc) </li>
</ul>
</li>
<li>设置响应头<ul>
<li>setHeader(String name, String value) </li>
</ul>
</li>
<li>设置响应体<ul>
<li>1.获取输出流<br>字符输出流：PrintWriter getWriter()<br>字节输出流：ServletOutputStream getOutputStream()</li>
<li>2.使用输出流，将数据输出到客户端浏览器</li>
</ul>
</li>
</ul>
<h3 id="5-2-案例"><a href="#5-2-案例" class="headerlink" title="5.2 案例"></a>5.2 案例</h3><h4 id="完成重定向"><a href="#完成重定向" class="headerlink" title="完成重定向"></a>完成重定向</h4><p><img src="/Java/JavaWeb/HTTP/HTTP学习笔记/重定向.bmp" alt="重定向" style="zoom:60%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//访问/responseDemo1，自动跳转到/responseDemo2资源</span></span><br><span class="line"><span class="comment">//1. 设置状态码为302</span></span><br><span class="line">response.setStatus(<span class="number">302</span>);</span><br><span class="line"><span class="comment">//2.设置响应头location</span></span><br><span class="line">response.setHeader(<span class="string">"location"</span>,<span class="string">"/Response/responseDemo2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态获取虚拟目录</span></span><br><span class="line">String contextPath = request.getContextPath();</span><br><span class="line"><span class="comment">//简单的重定向方法</span></span><br><span class="line">response.sendRedirect(contextPath+<span class="string">"/responseDemo2"</span>);</span><br><span class="line"><span class="comment">//response.sendRedirect("https://tommymerlin.gitee.io/");</span></span><br></pre></td></tr></table></figure>
<h5 id="重定向的特点：redirect"><a href="#重定向的特点：redirect" class="headerlink" title="重定向的特点：redirect"></a><strong>重定向</strong>的特点：redirect</h5><ul>
<li>地址栏发生变化。</li>
<li>重定向可以访问其他站点(服务器)的资源。</li>
<li>重定向是<strong>两次请求</strong>，不能使用request对象来共享数据。</li>
</ul>
<h5 id="转发的特点：forward"><a href="#转发的特点：forward" class="headerlink" title="转发的特点：forward"></a><strong>转发</strong>的特点：forward</h5><ul>
<li>转发地址栏路径不变。</li>
<li>转发只能访问当前服务器下的资源。</li>
<li>转发是<strong>一次请求</strong>，可以使用request对象来共享数据。</li>
</ul>
<h5 id="路径写法："><a href="#路径写法：" class="headerlink" title="路径写法："></a>路径写法：</h5><ul>
<li>路径分类：<ul>
<li><strong>相对路径</strong>：通过相对路径不可以确定唯一资源。<br>如：./index.html  不以/开头，以 . 开头<ul>
<li>规则：找到当前资源和目标资源之间的相对位置关系。<ul>
<li>./：当前目录</li>
<li>../：后退一级目录</li>
</ul>
</li>
</ul>
</li>
<li><strong>绝对路径</strong>：通过绝对路径可以确定唯一资源。<br>如：<a href="http://localhost/day15/responseDemo2" target="_blank" rel="noopener">http://localhost/day15/responseDemo2</a><br>​        /day15/responseDemo2<ul>
<li>规则：判断定义的路径是给谁用的？判断请求将来从哪发出。<ul>
<li>给客户端浏览器使用：需要加虚拟目录(项目的访问路径)。<ul>
<li>建议虚拟目录动态获取：request.getContextPath()</li>
</ul>
</li>
<li>给服务器使用：不需要加虚拟目录。<ul>
<li>转发路径</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="服务器输出字符数据到浏览器"><a href="#服务器输出字符数据到浏览器" class="headerlink" title="服务器输出字符数据到浏览器"></a>服务器输出字符数据到浏览器</h4><p>步骤</p>
<ul>
<li>获取字符输出流</li>
<li>输出数据</li>
</ul>
<p>乱码问题</p>
<ul>
<li>PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1。</li>
<li>设置编码（在获取流之前设置）。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">PrintWriter writer = response.getWriter();</span><br><span class="line">writer.write(<span class="string">"&lt;h1&gt;Hello Java&lt;/h1&gt;&lt;br&gt;&lt;a href='http://www.baidu.com'&gt;百度&lt;/a&gt;"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="服务器输出字节数据到浏览器"><a href="#服务器输出字节数据到浏览器" class="headerlink" title="服务器输出字节数据到浏览器"></a>服务器输出字节数据到浏览器</h4><p>步骤</p>
<ul>
<li>获取字节输出流</li>
<li>输出数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"><span class="comment">//1.获取字节输出流</span></span><br><span class="line">ServletOutputStream sos = response.getOutputStream();</span><br><span class="line"><span class="comment">//2.输出数据</span></span><br><span class="line">sos.write(<span class="string">"你好"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br></pre></td></tr></table></figure>
<h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p><a href="https://gitee.com/TommyMerlin/code-host/blob/master/Java/CheckCodeServlet.java" target="_blank" rel="noopener">代码</a></p>
<h2 id="6-ServletContext对象"><a href="#6-ServletContext对象" class="headerlink" title="6.ServletContext对象"></a>6.ServletContext对象</h2><h3 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1 概念"></a>6.1 概念</h3><p>代表整个 web 应用，可以和程序的容器(服务器)来通信</p>
<h3 id="6-2-获取"><a href="#6-2-获取" class="headerlink" title="6.2 获取"></a>6.2 获取</h3><ul>
<li>通过 <strong>request</strong> 对象获取。<ul>
<li>request.getServletContext();</li>
</ul>
</li>
<li>通过 <strong>HttpServlet</strong> 获取。<ul>
<li>this.getServletContext();</li>
</ul>
</li>
</ul>
<h3 id="6-3-功能"><a href="#6-3-功能" class="headerlink" title="6.3 功能"></a>6.3 功能</h3><ul>
<li><p>获取 <strong>MIME</strong> 类型：</p>
<ul>
<li>MIME 类型:在互联网通信过程中定义的一种文件数据类型。</li>
<li>格式： 大类型/小类型   text/html        image/jpeg</li>
<li>获取：String getMimeType(String file)</li>
</ul>
</li>
<li><p>域对象：<strong>共享数据</strong></p>
<ul>
<li>setAttribute(String name,Object value)</li>
<li>getAttribute(String name)</li>
<li>removeAttribute(String name)</li>
<li>ServletContext <strong>对象范围</strong>：所有用户所有请求的数据</li>
</ul>
</li>
<li><p>获取文件的<strong>真实(服务器)路径</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getRealPath</span><span class="params">(String path)</span>  </span></span><br><span class="line"><span class="function">String b </span>= context.getRealPath(<span class="string">"/b.txt"</span>);                <span class="comment">//web目录下资源访问</span></span><br><span class="line">System.out.println(b);</span><br><span class="line">	</span><br><span class="line">String c = context.getRealPath(<span class="string">"/WEB-INF/c.txt"</span>);        <span class="comment">//WEB-INF目录下的资源访问</span></span><br><span class="line">System.out.println(c);</span><br><span class="line">	</span><br><span class="line">String a = context.getRealPath(<span class="string">"/WEB-INF/classes/a.txt"</span>);<span class="comment">//src目录下的资源访问</span></span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-4-案例"><a href="#6-4-案例" class="headerlink" title="6.4 案例"></a>6.4 案例</h3><h4 id="文件下载需求"><a href="#文件下载需求" class="headerlink" title="文件下载需求"></a>文件下载需求</h4><ul>
<li>页面显示超链接。</li>
<li>点击超链接后弹出下载提示框。</li>
<li>完成图片文件下载。</li>
</ul>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框—&gt;<strong>不满足需求</strong></li>
<li>任何资源都必须弹出下载提示框。</li>
<li>使用响应头设置资源的打开方式：<pre><code>    * content-disposition:attachment;filename=xxx
</code></pre></li>
</ul>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>1.定义页面，编辑超链接 href 属性，指向 Servlet，传递资源名称 filename。</li>
<li>2.定义Servlet。<ul>
<li>a.获取文件名称</li>
<li>b.使用字节输入流加载文件进内存</li>
<li>c.指定response的响应头<br>content-disposition:attachment;filename=xxx</li>
<li>d.将数据写出到response输出流</li>
</ul>
</li>
</ul>
<h4 id="中文文件名问题"><a href="#中文文件名问题" class="headerlink" title="中文文件名问题"></a>中文文件名问题</h4><ul>
<li>获取客户端使用的浏览器版本信息。</li>
<li>根据不同的版本信息，设置filename的编码方式不同。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><blockquote>
<p>html文件</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/Response/downloadServlet?filename=1.jpg"</span>&gt;</span>图片1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>DownloadServlet.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取请求参数，文件名称</span></span><br><span class="line">String filename = request.getParameter(<span class="string">"filename"</span>);</span><br><span class="line"><span class="comment">//2.使用字节输入流加载文件进内存</span></span><br><span class="line"><span class="comment">//2.1找到文件服务器路径</span></span><br><span class="line">ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">String realPath = servletContext.getRealPath(<span class="string">"/img/"</span> + filename);</span><br><span class="line"><span class="comment">//2.2用字节流关联</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.设置response的响应头</span></span><br><span class="line"><span class="comment">//3.1设置响应头类型：content-type</span></span><br><span class="line">String mimeType = servletContext.getMimeType(filename);  <span class="comment">//获取文件的mime类型</span></span><br><span class="line">response.setHeader(<span class="string">"content-type"</span>,mimeType);  <span class="comment">//3.2设置响应头打开方式:content-disposition</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决中文文件名问题</span></span><br><span class="line"><span class="comment">//1.获取user-agent请求头、</span></span><br><span class="line">String agent = request.getHeader(<span class="string">"user-agent"</span>);</span><br><span class="line"><span class="comment">//2.使用工具类方法编码文件名即可</span></span><br><span class="line">filename = DownLoadUtils.getFileName(agent, filename);</span><br><span class="line"></span><br><span class="line">response.setHeader(<span class="string">"content-disposition"</span>,<span class="string">"attachment;filename="</span>+filename);</span><br><span class="line"><span class="comment">//4.将输入流的数据写出到输出流中</span></span><br><span class="line">ServletOutputStream sos = response.getOutputStream();</span><br><span class="line"><span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = fis.read(buff)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    sos.write(buff,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>工具类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownLoadUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFileName</span><span class="params">(String agent, String filename)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">        UnsupportedEncodingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (agent.contains(<span class="string">"MSIE"</span>)) &#123;</span><br><span class="line">            <span class="comment">// IE浏览器</span></span><br><span class="line">            filename = URLEncoder.encode(filename, <span class="string">"utf-8"</span>);</span><br><span class="line">            filename = filename.replace(<span class="string">"+"</span>, <span class="string">" "</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (agent.contains(<span class="string">"Firefox"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 火狐浏览器</span></span><br><span class="line">            BASE64Encoder base64Encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">            filename = <span class="string">"=?utf-8?B?"</span> + base64Encoder.encode(</span><br><span class="line">                filename.getBytes(<span class="string">"utf-8"</span>)) + <span class="string">"?="</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其它浏览器</span></span><br><span class="line">            filename = URLEncoder.encode(filename, <span class="string">"utf-8"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filename;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet学习笔记</title>
    <url>/Java/JavaWeb/Servlet/Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-Servlet-概述"><a href="#1-Servlet-概述" class="headerlink" title="1.Servlet 概述"></a>1.Servlet 概述</h2><ul>
<li><p><strong>概念</strong>：运行在服务器端的小程序。</p>
<ul>
<li>Servlet 就是一个<strong>接口</strong>，定义了 Java 类被浏览器访问（Tomcat识别）的规则。</li>
</ul>
</li>
<li><p><strong>快速入门</strong>：</p>
<ul>
<li>1.创建 JavaEE 项目。</li>
<li>2.定义一个类，实现 Servlet 接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerletDemo1</span> <span class="keyword">implements</span> <span class="title">Servlet</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>3.实现接口中的抽象方法。</li>
<li>4.配置 Servlet：<code>web\WEB-INF\web.xml</code>。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.coderhuye.web.servlet.ServerletDemo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行原理</strong>：</p>
<ul>
<li>1.当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径。</li>
<li>2.查找web.xml文件，是否有对应的<url-pattern>标签体内容。</url-pattern></li>
<li>3.如果有，则在找到对应的<servlet-class>全类名。</servlet-class></li>
<li>4.tomcat会将字节码文件加载进内存，并且创建其对象。</li>
<li>5.调用其方法。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-Servlet-生命周期"><a href="#2-Servlet-生命周期" class="headerlink" title="2.Servlet 生命周期"></a>2.Servlet 生命周期</h2><ul>
<li>1.<strong>创建</strong>：执行 init 方法，仅执行一次。<ul>
<li>Servlet 什么时候被创建？<ul>
<li>默认情况下，第一次访问时被创建。</li>
<li>可以在<servelet>标签下配置指定 Servlet 被创建的时机。<br><img src="/Java/JavaWeb/Servlet/Servlet学习笔记/配置Servlet创建时机.png" alt="配置Servlet创建时机" style="zoom:70%;"></servelet></li>
</ul>
</li>
</ul>
</li>
<li>Servlet 在内存中只有一个对象，是单例的。<ul>
<li>多个用户同时访问时，存在线程安全问题。</li>
<li>解决：尽量不在 Servlet 中定义成员变量。即使定义了成员变量，也不要对其修改值。</li>
</ul>
</li>
<li>2.<strong>提供服务</strong>：执行 sevice 方法，每访问一次 Servlet ，就会执行一次。</li>
<li>3.<strong>销毁</strong>：服务器正常关闭时执行一次。</li>
</ul>
<hr>
<h2 id="3-Servlet3-0"><a href="#3-Servlet3-0" class="headerlink" title="3.Servlet3.0"></a>3.Servlet3.0</h2><ul>
<li>支持注解配置</li>
<li>步骤：<ul>
<li>创建 JavaEE 项目，选择 Servlet 版本 &gt;3.0，可不创建 web.xml。</li>
<li>定义一个 Servlet 实现类。</li>
<li>复写方法<ul>
<li>在类上使用 @WebServlet 注解。<ul>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/demo1"</span>)</span><br><span class="line">or</span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/demo1"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-Servlet-体系结构"><a href="#4-Servlet-体系结构" class="headerlink" title="4.Servlet 体系结构"></a>4.Servlet 体系结构</h2><p><img src="/Java/JavaWeb/Servlet/Servlet学习笔记/Servlet继承关系.png" alt="Servlet继承关系" style="zoom:60%;"></p>
<ul>
<li>GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象方法。</li>
<li>HttpServlet：对http协议的一种封装，简化操作。<ul>
<li>定义类继承HttpServlet。</li>
<li>复写doGet/doPost方法。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-Servlet-相关配置"><a href="#5-Servlet-相关配置" class="headerlink" title="5.Servlet 相关配置"></a>5.Servlet 相关配置</h2><ul>
<li><p>urlPatterns：一个Servlet可以定义多个访问路径 ：</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(&#123;<span class="string">"/d4"</span>,<span class="string">"/demo4"</span>,<span class="string">"/dd4"</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>路径定义规则：</p>
<ul>
<li>/xxx：路径匹配</li>
<li>/xxx/xxx：多层路径，目录结构</li>
<li>*.do：扩展名匹配</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>在Linux服务器端手动部署Tomcat</title>
    <url>/Linux/%E5%9C%A8Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%89%8B%E5%8A%A8%E9%83%A8%E7%BD%B2Tomcat/</url>
    <content><![CDATA[<h2 id="1-安装-jdk-并配置路径"><a href="#1-安装-jdk-并配置路径" class="headerlink" title="1.安装 jdk 并配置路径"></a>1.安装 jdk 并配置路径</h2><p>将 jdk 解压放到 <code>/usr/local/</code> 目录下。</p>
<p>修改 <code>/etc/profile</code> 文档，在末尾添加如下语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.8.0_191</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure>
<p>刷新配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<h2 id="2-安装-Tomcat"><a href="#2-安装-Tomcat" class="headerlink" title="2.安装 Tomcat"></a>2.安装 Tomcat</h2><p>解压Tomcat压缩包。</p>
<p>修改 <code>/conf/server.xml</code>文件，将端口8080改为80。</p>
<p><img src="/Linux/在Linux服务器端手动部署Tomcat/修改Server配置.png" alt="修改Server配置" style="zoom:100%;"></p>
<h2 id="3-在阿里云服务器上添加安全组规则"><a href="#3-在阿里云服务器上添加安全组规则" class="headerlink" title="3.在阿里云服务器上添加安全组规则"></a>3.在阿里云服务器上添加安全组规则</h2><p>添加80端口的监听。</p>
<p><img src="/Linux/在Linux服务器端手动部署Tomcat/添加安全组规则.png" alt="添加安全组规则" style="zoom:60%;"></p>
<h2 id="4-启动-Tomcat-服务器"><a href="#4-启动-Tomcat-服务器" class="headerlink" title="4.启动 Tomcat 服务器"></a>4.启动 Tomcat 服务器</h2><p>执行 <code>/bin/startup.sh</code>脚本，启动服务器，访问服务器地址就能看到部署成功！</p>
<p><img src="/Linux/在Linux服务器端手动部署Tomcat/Tomcat.png" alt="Tomcat" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat部署项目的三种方式</title>
    <url>/Java/JavaWeb/Tomcat/Tomcat%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1-直接将项目放到webapps目录下"><a href="#1-直接将项目放到webapps目录下" class="headerlink" title="1.直接将项目放到webapps目录下"></a>1.直接将项目放到webapps目录下</h2><ul>
<li>项目的访问路径—&gt;虚拟路径</li>
<li>简化部署：将项目打包成一个war包，再将war包放置到webapps目录下<ul>
<li>war包会自动解压缩（热部署）</li>
</ul>
</li>
</ul>
<h2 id="2-配置conf-server-xml文件"><a href="#2-配置conf-server-xml文件" class="headerlink" title="2.配置conf/server.xml文件"></a>2.配置conf/server.xml文件</h2><p>在<host>标签体中配置</host></p>
<context daobase="D:\hello" path="/hello">

<ul>
<li>docBase：项目存放的路径</li>
<li>path：虚拟路径</li>
</ul>
<h2 id="3-在conf-Catalina-localhost创建任意名称的xml文件"><a href="#3-在conf-Catalina-localhost创建任意名称的xml文件" class="headerlink" title="3.在conf\Catalina\localhost创建任意名称的xml文件"></a>3.在conf\Catalina\localhost创建任意名称的xml文件</h2><p>在xml文件中编写<context daobase="D:\hello"></context></p>
<ul>
<li>虚拟目录：xml文件的名称</li>
</ul>
</context>]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构与实践 第2章-微服务架构综述</title>
    <url>/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%AC2%E7%AB%A0-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="1微服务架构概述"><a href="#1微服务架构概述" class="headerlink" title="1微服务架构概述"></a>1微服务架构概述</h2><p><strong>微服务定义</strong>(Martin Fowler)：微服务架构为一种架构模式，提倡将单一应用划分成<strong>一组小的服务</strong>，服务之间互相协调、互相配合。每个服务运行在<strong>独立进程</strong>中，服务间沟通采用<strong>轻量级通信机制</strong>。每个服务围绕具体业务构建，可<strong>独立部署</strong>。</p>
<h3 id="1-1-“微”的定义"><a href="#1-1-“微”的定义" class="headerlink" title="1.1 “微”的定义"></a>1.1 “微”的定义</h3><ul>
<li>代码行数：×</li>
<li>重写时间：×</li>
<li><strong>团队共识</strong><ul>
<li>业务独立性</li>
<li>团队自主性：人数≤10，全功能团队。</li>
</ul>
</li>
</ul>
<h3 id="1-2-单一职责"><a href="#1-2-单一职责" class="headerlink" title="1.2 单一职责"></a>1.2 单一职责</h3><ul>
<li><p><strong>高内聚，低耦合。</strong></p>
</li>
<li><p><strong>单一职责原则(SRP)</strong>：一个对象只能有一个发生变化的原因。若一个对象可被多个原因改变，则说明该对象承担了多个职责。</p>
</li>
</ul>
<h3 id="1-3-轻量级通信"><a href="#1-3-轻量级通信" class="headerlink" title="1.3 轻量级通信"></a>1.3 轻量级通信</h3><p><strong>轻量级通信</strong>：语言无关、平台无关的交互方式。</p>
<h3 id="1-4-独立性"><a href="#1-4-独立性" class="headerlink" title="1.4 独立性"></a>1.4 独立性</h3><p>在应用交付过程中，开发、测试以及部署的独立。</p>
<p><img src="/微服务/微服务读书笔记/微服务架构与实践第2章-微服务架构综述/独立性.png" alt="独立性" style="zoom:80%;"></p>
<h3 id="1-4-进程隔离"><a href="#1-4-进程隔离" class="headerlink" title="1.4 进程隔离"></a>1.4 进程隔离</h3><p><strong>单块架构</strong>：对应用进行部署时，需先停掉当前运行应用，部署完成后在重新启动，无法做到独立部署。</p>
<p><strong>微服务架构</strong>：每个服务均为高度自治的独立业务实体，能很容易地部署到不同的主机上。</p>
<p><img src="/微服务/微服务读书笔记/微服务架构与实践第2章-微服务架构综述/进程隔离.png" alt="进程隔离" style="zoom:80%;"></p>
<h2 id="2-微服务架构与SOA"><a href="#2-微服务架构与SOA" class="headerlink" title="2.微服务架构与SOA"></a>2.微服务架构与SOA</h2><h3 id="2-1-SOA概述"><a href="#2-1-SOA概述" class="headerlink" title="2.1 SOA概述"></a>2.1 SOA概述</h3><p><strong>SOA</strong>：对于复杂系统，按照不同的、可重用的粒度划分，将功能相关的一组功能提供者组织在一起为用户提供服务。</p>
<h3 id="2-2-微服务和SOA"><a href="#2-2-微服务和SOA" class="headerlink" title="2.2 微服务和SOA"></a>2.2 微服务和SOA</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">SOA实现</th>
<th style="text-align:left">微服务架构实现</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">企业级，自顶向下开展实施</td>
<td style="text-align:left">团队级，自底向上开展实施</td>
</tr>
<tr>
<td style="text-align:left">服务由多个子系统组成，粒度大</td>
<td style="text-align:left">一个系统被拆分成多个服务，粒度细</td>
</tr>
<tr>
<td style="text-align:left">企业服务总线，集中式的服务架构</td>
<td style="text-align:left">无集中式总线，松散的服务架构</td>
</tr>
<tr>
<td style="text-align:left">集成方式复杂（ESB/WS/SOAP）</td>
<td style="text-align:left">集成方式简单（HTTP/REST/JSON）</td>
</tr>
<tr>
<td style="text-align:left">单块架构系统，相互依赖，部署复杂</td>
<td style="text-align:left">服务能独立部署</td>
</tr>
</tbody>
</table>
</div>
<p><strong>微服务是SOA的子集</strong></p>
<h2 id="3-微服务的本质"><a href="#3-微服务的本质" class="headerlink" title="3.微服务的本质"></a>3.微服务的本质</h2><p>微服务本质特征：</p>
<ul>
<li>服务作为组件<ul>
<li>以松散的服务方式，构建<strong>可独立化部署</strong>的模块化应用</li>
<li>组件之间定义了清晰的、<strong>语言和平台无关</strong>的接口</li>
<li>分布式调用比进程内调用<strong>更耗时间</strong>，严重依赖网络可靠性与稳定性</li>
</ul>
</li>
<li>围绕业务组织团队<ul>
<li>以业务为核心，按业务能力组织团队，团队成员具有多样性的技能</li>
</ul>
</li>
<li>关注产品而非项目<ul>
<li>采用产品模式构建，团队负责服务的整个生命周期</li>
</ul>
</li>
<li>技术多样性<ul>
<li>针对不同业务选取合适的技术方案</li>
<li>易在系统上尝试新的技术和解决方案</li>
</ul>
</li>
<li>业务数据独立<ul>
<li>服务<strong>自主管理</strong>其相关的业务数据</li>
</ul>
</li>
<li>基础设施自动化<ul>
<li>部署与运维成本随服务增多呈指数级增长</li>
<li>对<strong>持续交付</strong>和<strong>部署流水线</strong>要求较高</li>
</ul>
</li>
<li>演进式架构<ul>
<li>能够不断调整软件的架构，不断演进</li>
</ul>
</li>
</ul>
<h2 id="4-微服务并非万能"><a href="#4-微服务并非万能" class="headerlink" title="4.微服务并非万能"></a>4.微服务并非万能</h2><p>微服务实施过程中，需考虑如下因素：</p>
<ul>
<li>分布式系统的复杂度<ul>
<li>性能</li>
<li>可靠性</li>
<li>异步</li>
<li>数据一致性</li>
<li>工具</li>
</ul>
</li>
<li>运维成本<ul>
<li>配置</li>
<li>部署</li>
<li>监控与告警</li>
<li>日志收集</li>
</ul>
</li>
<li>部署自动化</li>
<li>DevOps与组织架构<ul>
<li>按需调整组织架构，构建全功能团队</li>
</ul>
</li>
<li>服务间依赖测试</li>
<li>服务间依赖管理</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
        <category>微服务读书笔记</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构与实践 第1章-单块架构及其面临的挑战</title>
    <url>/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%AC1%E7%AB%A0-%E5%8D%95%E5%9D%97%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98/</url>
    <content><![CDATA[<h2 id="1-三层应用架构"><a href="#1-三层应用架构" class="headerlink" title="1.三层应用架构"></a>1.三层应用架构</h2><h3 id="1-1-三层架构"><a href="#1-1-三层架构" class="headerlink" title="1.1 三层架构"></a>1.1 三层架构</h3><ul>
<li><strong>表示层</strong>：用户交互部分。</li>
<li><strong>业务逻辑层</strong>：根据用户输入信息，进行逻辑运算或业务处理。</li>
<li><strong>数据访问层</strong>：有效地将数据存储到数据库、文件系统等。</li>
</ul>
<p><img src="/微服务/微服务读书笔记/微服务架构与实践第1章-单块架构及其面临的挑战/三层架构.png" alt="三层架构" style="zoom:80%;"></p>
<h3 id="1-2-三层架构优势"><a href="#1-2-三层架构优势" class="headerlink" title="1.2 三层架构优势"></a>1.2 三层架构优势</h3><ul>
<li>解决应用程序中代码间调用复杂、代码职责不清问题。</li>
<li>接口与实现分离，易于用不同实现替代现有实现。</li>
<li>有效降低层与层之间的依赖。</li>
<li>使不同职责人负责不同部分。</li>
</ul>
<h2 id="2-单块架构"><a href="#2-单块架构" class="headerlink" title="2.单块架构"></a>2.单块架构</h2><h3 id="2-1-单块架构定义"><a href="#2-1-单块架构定义" class="headerlink" title="2.1 单块架构定义"></a>2.1 单块架构定义</h3><p><strong>单块架构应用</strong>：功能集中、代码和数据中心化、一个发布包、部署后运行在同一进程的应用程序。</p>
<h3 id="2-2-单块架构优势"><a href="#2-2-单块架构优势" class="headerlink" title="2.2 单块架构优势"></a>2.2 单块架构优势</h3><ul>
<li>易于开发</li>
<li>易于测试</li>
<li>易于部署</li>
<li>易于水平伸缩</li>
</ul>
<h3 id="2-3-单块架构面临的挑战"><a href="#2-3-单块架构面临的挑战" class="headerlink" title="2.3 单块架构面临的挑战"></a>2.3 单块架构面临的挑战</h3><ul>
<li>维护成本增加</li>
<li>持续交付时间长</li>
<li>新人培养周期长</li>
<li>技术选型成本高</li>
<li>可扩展性差<ul>
<li>垂直扩展——成本高</li>
<li>水平扩展——建立集群，在集群中不断增加新节点</li>
</ul>
</li>
<li>构建全功能团队难</li>
</ul>
<blockquote>
<p><strong>垂直伸缩</strong>: 升级到更强大的服务器（多CPU 昂贵大中型机）。<br><strong>水平伸缩</strong>: 增加更便宜的机器。</p>
</blockquote>
]]></content>
      <categories>
        <category>微服务</category>
        <category>微服务读书笔记</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab打开后长时间处于“正在初始化”或“正忙”状态解决办法</title>
    <url>/%E6%95%99%E7%A8%8B/Matlab%E6%89%93%E5%BC%80%E5%90%8E%E9%95%BF%E6%97%B6%E9%97%B4%E5%A4%84%E4%BA%8E%E2%80%9C%E6%AD%A3%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E2%80%9D%E6%88%96%E2%80%9C%E6%AD%A3%E5%BF%99%E2%80%9D%E7%8A%B6%E6%80%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-许可证问题"><a href="#1-许可证问题" class="headerlink" title="1.许可证问题"></a>1.许可证问题</h2><h3 id="1-1-解决方法1"><a href="#1-1-解决方法1" class="headerlink" title="1.1 解决方法1"></a>1.1 解决方法1</h3><p>MATLAB 在启动时，一直停留在“正在初始化”的状态，有可能是因为 MATLAB 一直在找着本机的许可证。</p>
<p>有可能是设置了 <code>LM_LICENSE_FILE</code> 的环境变量。这个变量告诉 MATLAB 或者其他应用程序去哪里查找许可证文件。如果您有一个网络许可证，但是当前又没有联网，那么 MATLAB 就会一直停留在这个状态。</p>
<p><strong>注意</strong>：还有一个环境变量 <code>MLM_LICENSE_FILE</code> 也会导致这一问题。这个环境变量只用于 MATLAB。</p>
<p>要解决这个问题，您可以执行以下操作：</p>
<ul>
<li>1.右击“<strong>我的电脑</strong>”，然后选择“<strong>属性</strong>”。（有可能需要在控制面板中双击“系统”）。</li>
<li>2.选择“<strong>高级</strong>”标签，点击“<strong>环境变量</strong>”。</li>
<li>3.在窗口下方的系统变量中，查找变量 <code>LM_LICENSE_FILE</code>。</li>
<li>4.如果有 <code>LM_LICENSE_FILE</code> 变量存在，请看第5步。如果没有，请创建一个 <code>LM_LICENSE_FILE</code> 变量：点击“新建”，然后在变量名框中输入 <code>LM_LICENSE_FILE</code>。</li>
<li>5.把 <code>LM_LICENSE_FILE</code> 的值设为 MATLAB <strong>许可证文件的绝对路径</strong>。如果有多个许可证文件，在第一个路径后加上分号（；），然后在写第二个路径。点击“确认”保存。</li>
<li>6.<strong>重新启动</strong> MATLAB。</li>
</ul>
<h3 id="1-2-解决方法2"><a href="#1-2-解决方法2" class="headerlink" title="1.2 解决方法2"></a>1.2 解决方法2</h3><p>如果您仅使用一个许可证来访问 MATLAB 和工具箱，可以在 MATLAB <strong>快捷方式</strong>中指定许可证文件或在启动 MATLAB 时从命令行中指定许可证文件。要实现以上目的，请执行下列步骤：</p>
<ul>
<li>1）右击 MATLAB 的快捷方式并选择“<strong>属性</strong>”。</li>
<li>2）在“<strong>目标</strong>”字段中，输入以下内容：</li>
</ul>
<blockquote>
<p>“$MATLAB\bin\win32\MATLAB.exe” -c “&lt;包括文件名的 MATLAB 许可证文件的完整路径&gt;“</p>
</blockquote>
<p>其中 $MATLAB 是 MATLAB <strong>根目录</strong>，<matlab 许可证文件的路径> 是许可证文件的<strong>绝对路径</strong>。</matlab></p>
<ul>
<li>3）点击“确定”。</li>
<li>4）从快捷方式启动 MATLAB。</li>
</ul>
<h2 id="2-非许可问题"><a href="#2-非许可问题" class="headerlink" title="2.非许可问题"></a>2.非许可问题</h2><h3 id="2-1-解决方法1"><a href="#2-1-解决方法1" class="headerlink" title="2.1 解决方法1"></a>2.1 解决方法1</h3><p><strong>首先确保您已允许查看隐藏文件和文件夹。</strong></p>
<ul>
<li>1.<strong>退出 MATLAB</strong>。确保 MATLAB 不再运行。</li>
<li>2.浏览到文件夹 <code>c:\Documents and Settings\ &lt;your username&gt;\Application Data\MathWorks\MATLAB\</code>或 <code>c:\users\&lt;username&gt;\AppData\Roaming</code></li>
<li>3.<strong>重命名</strong>您使用的 MATLAB 版本目录，以 <code>_old</code> 结尾。如果有名称中包含<code>_licenses</code>的文件夹，不要重命名该文件夹。</li>
<li>4.在<strong>删除</strong>了此目录之后，<strong>重新启动</strong> MATLAB。下次您启动 MATLAB 时会重新创建此目录。</li>
</ul>
<p>如果这没有解决问题，则可以考虑 Windows 上的 MATLAB 7.0 (R14) 和某些显卡提供的图形库之间存在的一个已知问题，这些显卡没有高效使用内存，因而使 MATLAB 7.0 (R14) 比预期更频繁地使用虚拟内存。在这种情况下，禁用显卡卡的硬件图形加速功能可以提高 MATLAB 7.0 (R14) 的性能。为此，请执行下列步骤。</p>
<ul>
<li>1.<strong>关闭</strong> MATLAB。</li>
<li>2.右击 Windows 桌面并选择“<strong>属性</strong>”。</li>
<li>3.在打开的“<strong>显示属性</strong>”窗口中，选择“<strong>设置</strong>”选项卡，然后点击“<strong>高级</strong>”按钮。</li>
<li>4.在打开的窗口中，选择“<strong>疑难解答</strong>”选项卡。</li>
<li>5.将“<strong>硬件加速</strong>”滑动条一直向左设置为“<strong>无</strong>”。</li>
<li>6.点击此窗口中的“确定”，然后再次点击“<strong>显示属性</strong>”窗口中的“确定”。</li>
<li>7.<strong>重新启动</strong> MATLAB。</li>
</ul>
<h3 id="2-2-解决方法2"><a href="#2-2-解决方法2" class="headerlink" title="2.2 解决方法2"></a>2.2 解决方法2</h3><p>在一些情况下，客户报告在后台运行的防病毒程序会降低 MATLAB 的速度。对于这些客户，<strong>禁止防病毒软件扫描 MATLAB 目录</strong>可以大大提高性能。</p>
<p><a href="https://ww2.mathworks.cn/matlabcentral/answers/116115-matlab" target="_blank" rel="noopener">参考链接</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法第七章—支持向量机</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="/机器学习/统计学习方法/统计学习第七章学习笔记/支持向量机.png" alt="支持向量机" style="zoom:40%;"></p>
<h2 id="1-线性可分支持向量机与硬间隔最大化"><a href="#1-线性可分支持向量机与硬间隔最大化" class="headerlink" title="1.线性可分支持向量机与硬间隔最大化"></a>1.线性可分支持向量机与硬间隔最大化</h2><h3 id="1-1-线性可分支持向量机"><a href="#1-1-线性可分支持向量机" class="headerlink" title="1.1 线性可分支持向量机"></a>1.1 线性可分支持向量机</h3><p><strong>支持向量机：二类分类</strong></p>
<p>在特征空间中找到以一个分离超平面将实例分到不同的类。</p>
<blockquote>
<p>感知机：误分类最小策略，解无穷多。<br>线性可分支持向量机：间隔最大化策略，解唯一。</p>
</blockquote>
<h3 id="1-2-函数间隔和几何间隔"><a href="#1-2-函数间隔和几何间隔" class="headerlink" title="1.2 函数间隔和几何间隔"></a>1.2 函数间隔和几何间隔</h3><p><strong>函数间隔</strong>：表示分类预测的正确性及确信度，超平面 $(w,b)$ 关于样本点 $(x_i,y_i)$ 的函数间隔为</p>
<script type="math/tex; mode=display">
\hat{\gamma}_{i}=y_{i}\left(w \cdot x_{i}+b\right)</script><p>超平面 $(w,b)$ 关于训练数据集 T 的函数间隔为超平面 $(w,b)$ 关于 T 中所有样本点 $(x_i,y_i)$ 的函数间隔之最小值，即</p>
<script type="math/tex; mode=display">
\hat{\gamma}=\min _{i=1, \cdots, N} \hat{\gamma}_{i}</script><p><strong>几何间隔</strong>：对分离超平面的法向量w加上规范化约束，使得间隔为确定值，此时函数间隔→几何间隔，超平面 $(w,b)$ 关于样本点 $(x_i,y_i)$ 的几何间隔为</p>
<script type="math/tex; mode=display">
\gamma_{i}=y_{i}\left(\frac{w}{\|w\|} \cdot x_{i}+\frac{b}{\|w\|}\right)</script><p>其中 $|w|$ 为 w 的 $L_2$ 范数。</p>
<p><img src="/机器学习/统计学习方法/统计学习第七章学习笔记/几何间隔.png" alt="几何间隔" style="zoom:60%;"></p>
<p>超平面 $(w,b)$ 关于训练数据集 T 的几何间隔为超平面 $(w,b)$ 关于 T 中所有样本点 $(x_i,y_i)$ 的几何间隔之最小值，即</p>
<script type="math/tex; mode=display">
\gamma=\min _{i=1, \cdots, N} \gamma_{i}</script><p>函数间隔和几何间隔的<strong>关系</strong>：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\gamma_{i}&=\frac{\hat{\gamma}_{i}}{\|w\|}\\
\gamma&=\frac{\hat{\gamma}}{\|w\|}
\end{aligned}</script><h3 id="1-3-间隔最大化"><a href="#1-3-间隔最大化" class="headerlink" title="1.3 间隔最大化"></a>1.3 间隔最大化</h3><p>支持向量机<strong>基本思想</strong>：求解能够正确划分训练集并且几何间隔最大的分离超平面。</p>
<h4 id="1-3-1最大间隔分离超平面"><a href="#1-3-1最大间隔分离超平面" class="headerlink" title="1.3.1最大间隔分离超平面"></a>1.3.1最大间隔分离超平面</h4><p>求解几何间隔最大的分离超平面即为<strong>求解约束最优化问题</strong>：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}{\max _{w, b}} & {\frac{\hat{\gamma}}{\|w\|}} \\ {\text { s.t. }} & {y_{i}\left(w \cdot x_{i}+b\right) \geqslant \hat{\gamma}, \quad i=1,2, \cdots, N}\end{array}</script><p>函数间隔 $\hat{\gamma}$  的取值不影响最优化问题的解，故可取 $\hat{\gamma}=1$ ，由于最大化  $\frac{1}{|w|}$ 和最小化 $\frac{1}{2}{|w|}^2$ 是等价的，可将原问题转化为下面的最优化问题（<strong>原始问题</strong>）：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}{\min _{w, b}} & {\frac{1}{2}\|w\|^{2}} \\ {\text { s.t. }} & {y_{i}\left(w \cdot x_{i}+b\right)-1 \geqslant 0, \quad i=1,2, \cdots, N}\end{array}</script><p>求得最优解 $w^<em>$,$b^</em>$，就可得到最大间隔分离超平面 $w^<em>\cdot x+b^</em>=0$ 及分类决策函数 $f(x)=sign(w^<em>\cdot x+b^</em>)$ 。</p>
<h4 id="1-3-2支持向量和间隔边界"><a href="#1-3-2支持向量和间隔边界" class="headerlink" title="1.3.2支持向量和间隔边界"></a>1.3.2支持向量和间隔边界</h4><p><strong>支持向量</strong>：与分离超平面距离最近的样本点的实例，满足 $y_{i}\left(w \cdot x_{i}+b\right)-1=0$ 。</p>
<p><img src="/机器学习/统计学习方法/统计学习第七章学习笔记/支持向量.png" alt="支持向量" style="zoom:60%;"></p>
<p><strong>间隔边界</strong>：$H_1$ 和 $H_2$，其中</p>
<script type="math/tex; mode=display">
\begin{aligned}
H_{1}&: w \cdot x+b=1\\
H_{2}&: w \cdot x+b=-1
\end{aligned}</script><p><strong>间隔</strong>：$H_1$ 和 $H_2$ 之间的距离，等于 $\frac{2}{|w|}$ 。</p>
<h3 id="1-4学习的对偶算法"><a href="#1-4学习的对偶算法" class="headerlink" title="1.4学习的对偶算法"></a>1.4学习的对偶算法</h3><p><strong>对偶问题</strong>：</p>
<script type="math/tex; mode=display">
\begin{array}{cl}{\min _{\alpha}} & {\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)-\sum_{i=1}^{N} \alpha_{i}} \\ {\text { s.t. }} & {\sum_{i=1}^{N} \alpha_{i} y_{i}=0} \\ {} & {\alpha_{i} \geqslant 0, \quad i=1,2, \cdots, N}\end{array}</script><p>设 $\alpha^{<em>}=\left(\alpha_{1}^{</em>}, \alpha_{2}^{<em>}, \cdots, \alpha_{l}^{</em>}\right)^{\mathrm{T}}$ 是对偶问题的解，则存在下标 j ，使得 $\alpha_{j}^{<em>}&gt;0$ ，并可通过下式求得原始问题的解 $w^</em>$,$b^*$：</p>
<script type="math/tex; mode=display">
\begin{aligned} w^{*} &=\sum_{i=1}^{N} \alpha_{i}^{*} y_{i} x_{i} \\ b^{*}&=y_{j} -\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}\left(x_{i} \cdot x_{j}\right) \end{aligned}</script><p><strong>支持向量</strong>：训练数据集中对应于 $\alpha_{i}^{*}&gt;0$ 的样本点 $(x_i,y_i)$ 的实例 $x_i\in R^n$ ，也即  $y_{i}\left(w \cdot x_{i}+b\right)-1=0$ 。</p>
<h2 id="2-线性支持向量机与软间隔最大化"><a href="#2-线性支持向量机与软间隔最大化" class="headerlink" title="2.线性支持向量机与软间隔最大化"></a>2.线性支持向量机与软间隔最大化</h2><h3 id="2-1线性支持向量机"><a href="#2-1线性支持向量机" class="headerlink" title="2.1线性支持向量机"></a>2.1线性支持向量机</h3><p>训练集中存在一些<strong>特异点</strong>，即这些样本点不满足函数间隔大于等于1的约束条件，为解决这一问题，可对每个样本点 $(x_i,y_i)$ 引入一个<strong>松弛变量</strong>  $\xi_{i} \geqslant 0$ ，是函数间隔大于等于1，此时约束条件变为：</p>
<script type="math/tex; mode=display">
y_{i}\left(w \cdot x_{i}+b\right) \geqslant 1-\xi_{i}</script><p>目标函数变为：</p>
<script type="math/tex; mode=display">
\frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{N} \xi_{i}</script><p>其中，$C&gt;0$ 称为<strong>惩罚函数</strong>，C值越大，对误分类的惩罚越大。</p>
<p><strong>最小化目标函数的含义</strong>：</p>
<ul>
<li>使 $\frac{1}{2}|w|^{2}$ 尽量小，即间隔尽量大</li>
<li>使误分类点的个数尽量小</li>
</ul>
<p><strong>原始问题</strong>：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}{\min _{w, b, \xi}} & {\frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{N} \xi_{i}} \\ {\text { s.t. }} & {y_{i}\left(w \cdot x_{i}+b\right) \geqslant 1-\xi_{i}, \quad i=1,2, \cdots, N} \\ {} & {\xi_{i} \geqslant 0, \quad i=1,2, \cdots, N}\end{array}</script><p>w的解唯一，b的解存在于一个区间。</p>
<p><strong>对偶问题</strong>：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}{\min _{\alpha}} & {\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)-\sum_{i=1}^{N} \alpha_{i}} \\ {\text { s.t. }} & {\sum_{i=1}^{N} \alpha_{i} y_{i}=0} \\ {} & {0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2, \cdots, N}\end{array}</script><p>设 $\alpha^{<em>}=\left(\alpha_{1}^{</em>}, \alpha_{2}^{<em>}, \cdots, \alpha_{l}^{</em>}\right)^{\mathrm{T}}$ 是对偶问题的解，若存在 $\alpha^<em>$ 的一个分量 $\alpha^</em>_j$ ，$0&lt;\alpha^<em>_j&lt;C$，则可通过下式求得原始问题的解 $w^</em>$,$b^*$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
w^{*}&=\sum_{i=1}^{N} \alpha_{i}^{*} y_{i} x_{i} \\ 
b^{*}&=y_{j}-\sum_{i=1}^{N} y_{i} \alpha_{i}^{*}(x_{i}\cdot x_{j})
\end{aligned}</script><p>由于 b 的解不唯一，可在满足条件的样本点上取平均值。</p>
<h3 id="2-2支持向量"><a href="#2-2支持向量" class="headerlink" title="2.2支持向量"></a>2.2支持向量</h3><p><strong>支持向量</strong>：对偶问题的解 $\alpha^{<em>}=\left(\alpha_{1}^{</em>}, \alpha_{2}^{<em>}, \cdots, \alpha_{l}^{</em>}\right)^{\mathrm{T}}$ 中对应于 $\alpha^*_i&gt;0$ 的样本点的实例。</p>
<p><img src="/机器学习/统计学习方法/统计学习第七章学习笔记/软间隔的支持向量.png" alt="软间隔的支持向量" style="zoom:60%;"></p>
<p><strong>$\alpha^*$ 不同大小代表支持向量不同位置：</strong></p>
<ul>
<li>若 $\alpha^*_i&gt;C$ ，则 $\xi_i=0$ ，支持向量 $x_i$ 恰好落在间隔边界上。</li>
<li>若 $\alpha^*_i=C$ ，则 $0&lt;\xi_i&lt;0$ ，$x_i$ 在间隔边界与分离超平面之间。</li>
<li>若 $\alpha^*_i=C$ ，则 $\xi_i=1$ ，支持向量 $x_i$ 在分离超平面上。</li>
<li>若 $\alpha^*_i=C$ ，则 $\xi_i&gt;0$ ，支持向量 $x_i$ 在分离超平面误分一侧。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>统计学习方法</tag>
        <tag>监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法第六章—逻辑斯谛回归与最大熵模型</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-逻辑斯谛回归模型"><a href="#1-逻辑斯谛回归模型" class="headerlink" title="1.逻辑斯谛回归模型"></a>1.逻辑斯谛回归模型</h2><h3 id="1-1-逻辑斯谛分布"><a href="#1-1-逻辑斯谛分布" class="headerlink" title="1.1 逻辑斯谛分布"></a>1.1 逻辑斯谛分布</h3><p><strong>逻辑斯谛分布</strong>：X是连续随机变量，X服从逻辑斯谛分布指其具有下列分布函数和密度函数：</p>
<script type="math/tex; mode=display">
\begin{array}{l}{F(x)=P(X \leqslant x)=\frac{1}{1+\mathrm{e}^{-(x-\mu) / \gamma}}} \\ {f(x)=F^{\prime}(x)=\frac{\mathrm{e}^{-(x-\mu) / \gamma}}{\gamma\left(1+\mathrm{e}^{-(x-\mu) / \gamma}\right)^{2}}}\end{array}</script><p>其中 $\mu$ 为位置参数，$\gamma&gt;0$ 为形状参数。</p>
<p>f(x) 与 F(x) 图形如下图所示，为 S 形曲线(sigmoid curve)，以点 $(\mu,\frac{1}{2})$ 中心对称。$\gamma$ 越小 ，曲线在中心附近增长得越快。</p>
<p><img src="/机器学习/统计学习方法/统计学习第六章学习笔记/逻辑斯谛分布密度函数.png" alt="逻辑斯谛分布密度函数" style="zoom:60%;"></p>
<h3 id="1-2-二项逻辑斯谛回归模型"><a href="#1-2-二项逻辑斯谛回归模型" class="headerlink" title="1.2 二项逻辑斯谛回归模型"></a>1.2 二项逻辑斯谛回归模型</h3><p><strong>逻辑斯谛回归模型</strong>：如下条件概率分布：</p>
<script type="math/tex; mode=display">
\begin{array}{l}{P(Y=1 | x)=\frac{\exp (w \cdot x)}{1+\exp (w \cdot x)}} \\ {P(Y=0 | x)=\frac{1}{1+\exp (w \cdot x)}}\end{array}</script><p>其中 $w=\left(w^{(1)}, w^{(2)}, \cdots, w^{(n)}, b\right)^{\mathrm{T}}$ ， $x=\left(x^{(1)}, x^{(2)}, \cdots, x^{(n)}, 1\right)^{\mathrm{T}}$。</p>
<p>逻辑斯谛回归比较两个条件概率值的大小，将实例 x 分到概率值较大的那一类。</p>
<p>一个事件(发生概率为p)的对数几率或 logit 函数是：</p>
<script type="math/tex; mode=display">
\operatorname{logit}(p)=\log \frac{p}{1-p}</script><p>对于逻辑斯谛回归，可得</p>
<script type="math/tex; mode=display">
\log \frac{P(Y=1 | x)}{1-P(Y=1 | x)}=w \cdot x</script><p>即输出 Y=1 的对数几率是输入 x 的线性函数。</p>
<h3 id="1-3-模型参数估计"><a href="#1-3-模型参数估计" class="headerlink" title="1.3 模型参数估计"></a>1.3 模型参数估计</h3><p>极大似然估计法</p>
<p>令 $P(Y=1 | x)=\pi(x),\ P(Y=0 | x)=1-\pi(x)$ </p>
<p>似然函数为 $\prod_{i=1}^{N}\left[\pi\left(x_{i}\right)\right]^{y_{i}}\left[1-\pi\left(x_{i}\right)\right]^{1-y_{i}}$ </p>
<p>对数似然函数为</p>
<script type="math/tex; mode=display">
L(w) =\sum_{i=1}^{N}[y_{i}\left(w \cdot x_{i}\right)-\log \left(1+\exp \left(w \cdot x_{i}\right)\right]</script><p>对 L(w) 求极大值，得到 w 的估计值：</p>
<ul>
<li>梯度下降法</li>
<li>拟牛顿法</li>
</ul>
<h2 id="2-最大熵模型"><a href="#2-最大熵模型" class="headerlink" title="2.最大熵模型"></a>2.最大熵模型</h2><h3 id="2-1-最大熵原理"><a href="#2-1-最大熵原理" class="headerlink" title="2.1 最大熵原理"></a>2.1 最大熵原理</h3><p><strong>最大熵原理</strong>：熵最大的模型是最好的模型，当 X 服从均匀分布时，熵最大。</p>
<h3 id="2-2-最大熵模型定义"><a href="#2-2-最大熵模型定义" class="headerlink" title="2.2 最大熵模型定义"></a>2.2 最大熵模型定义</h3>]]></content>
      <categories>
        <category>机器学习</category>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>统计学习方法</tag>
        <tag>监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>监督学习各方法比较</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E5%90%84%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h2 id="1-感知机"><a href="#1-感知机" class="headerlink" title="1.感知机"></a>1.感知机</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>模型简单易懂，便于编程实现；</li>
<li>是许多后续算法如SVM、神经网络、深度学习的基础。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>只能对线性可分数据集进行学习；</li>
<li>不同参数设置会学到不同模型，泛化能力好差。</li>
</ul>
<h2 id="2-k近邻法"><a href="#2-k近邻法" class="headerlink" title="2.k近邻法"></a>2.k近邻法</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>理论成熟，思想简单，既可以用来做分类也可以用来做回归；</li>
<li>可用于非线性分类，可以生成任意形状的决策边界；</li>
<li>训练时间复杂度为O(n)，因为是消极的学习方法不需要建立模型；</li>
<li>对数据没有假设，准确度高，对outlier（离群值、逸出值）不敏感；</li>
<li>基于局部信息进行预测，正因为这样而局部分类决策，KNN（k很小时）对噪声非常敏感。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>计算量大（体现在距离计算上），因为需要逐个计算测试样例和训练样例之间的而相似度；  </li>
<li>样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）效果差；   </li>
<li>需要大量内存；  </li>
<li>除非采用适当的邻近性度量k和数据预处理，否则最近邻分类器可能做出错误的预测。</li>
</ul>
<h2 id="3-朴素贝叶斯法"><a href="#3-朴素贝叶斯法" class="headerlink" title="3.朴素贝叶斯法"></a>3.朴素贝叶斯法</h2><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>有坚实的数学基础，以及稳定的分类效率；</li>
<li>对小规模的数据表现很好，能个处理多分类任务，适合增量式训练；</li>
<li>面对孤立的噪声点，朴素贝叶斯分类器是健壮的。通过在建模和分类时忽略样例，朴素贝叶斯法对缺失数据不太敏感，算法也比较简单，常用于文本分类；</li>
<li>面对无关属性，朴素贝叶斯法是健壮的。如果 $X_i$ 是无关属性，那么 $P(X_i,Y_i)$ 几乎变成了均匀分布。 $X_i$ 的类条件概率不会对总的后验概率的计算产生影响。</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>需要计算先验概率；</li>
<li>分类决策存在错误率；</li>
<li>对输入数据的表达形式很敏感；</li>
<li>输入变量必须都是条件独立的，如果假设它们之间存在概率依存关系，模型就变成了贝叶斯网，相关属性可能会降低朴素贝叶斯分类器的性能。</li>
</ul>
<h2 id="4-决策树"><a href="#4-决策树" class="headerlink" title="4.决策树"></a>4.决策树</h2><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul>
<li>计算简单，易于理解，可解释性强；</li>
<li>比较适合处理有缺失属性的样本；</li>
<li>能够处理不相关的特征；</li>
<li>在相对短的时间内能够对大型数据源做出可行且效果良好的结果。</li>
</ul>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>容易发生过拟合（随机森林可以很大程度上减少过拟合），剪枝是解决决策树过拟合并缩小决策树的方法之一；</li>
<li>忽略了数据之间的相关性；</li>
<li>对于那些各类别样本数量不一致的数据，在决策树当中,信息增益的结果偏向于那些具有更多数值的特征（只要是使用了信息增益，都有这个缺点，如RF）。</li>
</ul>
<h2 id="5-支持向量机"><a href="#5-支持向量机" class="headerlink" title="5.支持向量机"></a>5.支持向量机</h2><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ul>
<li>可以解决高维问题，即大型特征空间；</li>
<li>能够处理非线性特征的相互作用；</li>
<li>无需依赖整个数据；</li>
<li>可以提高泛化能力。</li>
</ul>
<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>当观测样本很多时，效率并不是很高，因为在大数据中，SVM时间复杂度为<img src="https://www.zhihu.com/equation?tex=O%28n%5E%7B3%7D%29+" alt="[公式]">；</li>
<li>对非线性问题没有通用解决方案，有时候很难找到一个合适的核函数；</li>
<li>在噪声过多的情况下，SVM容易造成过拟合；</li>
<li>类严重重叠时，SVM的表现也很差；</li>
<li>对缺失数据敏感。</li>
</ul>
<h2 id="6-逻辑斯谛回归"><a href="#6-逻辑斯谛回归" class="headerlink" title="6.逻辑斯谛回归"></a>6.逻辑斯谛回归</h2><h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><ul>
<li>实现简单，广泛的应用于工业问题上；</li>
<li>分类时计算量非常小，速度很快，存储资源低；</li>
<li>便利的观测样本概率分数；</li>
<li>对逻辑回归而言，多重共线性并不是问题，它可以结合L2正则化来解决该问题。</li>
</ul>
<h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>当特征空间很大时，逻辑回归的性能不是很好；</li>
<li>容易欠拟合，一般准确度不太高；</li>
<li>不能很好地处理大量多类特征或变量。</li>
<li>只能处理两分类问题（在此基础上衍生出来的softmax可以用于多分类），且必须<strong>线性可分</strong>；</li>
<li>对于非线性特征，需要进行转换。</li>
</ul>
<h2 id="7-提升方法AdaBoost算法"><a href="#7-提升方法AdaBoost算法" class="headerlink" title="7.提升方法AdaBoost算法"></a>7.提升方法AdaBoost算法</h2><h3 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h3><ul>
<li>Adaboost是一种有很高精度的分类器；</li>
<li>可以使用各种方法构建子分类器，Adaboost算法提供的是框架；</li>
<li>当使用简单分类器时，计算出的结果是可以理解的，并且弱分类器的构造极其简单；</li>
<li>简单，不用做特征筛选；</li>
<li>不易发生overfitting。</li>
</ul>
<h3 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>对outlier比较敏感。</li>
</ul>
<h2 id="8-人工神经网络"><a href="#8-人工神经网络" class="headerlink" title="8.人工神经网络"></a>8.人工神经网络</h2><h3 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h3><ul>
<li>分类的准确度高；</li>
<li>并行分布处理能力强,分布存储及学习能力强；</li>
<li>对噪声神经有较强的鲁棒性和容错能力，能充分逼近复杂的非线性关系；</li>
<li>具备联想记忆的功能；</li>
<li>ANN可以处理冗余特征，因为权值在训练过程中自动学习。冗余特征的权值非常小；</li>
<li>测试样例分类时非常快。</li>
</ul>
<h3 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>神经网络需要大量的参数，如网络拓扑结构、权值和阈值的初始值；</li>
<li>不能观察之间的学习过程，输出结果难以解释，会影响到结果的可信度和可接受程度；</li>
<li>学习时间过长,特别是当隐藏结点数量很大时，甚至可能达不到学习的目的。</li>
<li>ANN权值学习使用的梯度下降方法经常会收敛到局部最优解。避免局部最优解的方法: 在权值更新公式中加上一个冲量（momentum term）；使用高价的导数；随机优化思想</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>统计学习方法</tag>
        <tag>监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法第五章—决策树</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-决策树模型与学习"><a href="#1-决策树模型与学习" class="headerlink" title="1.决策树模型与学习"></a>1.决策树模型与学习</h2><h3 id="1-1-决策树模型"><a href="#1-1-决策树模型" class="headerlink" title="1.1 决策树模型"></a>1.1 决策树模型</h3><p>内部节点代表一个特征或属性，叶结点代表一个类。</p>
<div align="center">    
<img src="https://raw.githubusercontent.com/TommyMerlin/Image-Hosting/master/ML/%E5%86%B3%E7%AD%96%E6%A0%91%E6%A8%A1%E5%9E%8B.png" width="300" height="250" alt="图片名称" align="center">
<p>决策树模型</p>
</div>

<h3 id="1-2-决策树与if-then规则"><a href="#1-2-决策树与if-then规则" class="headerlink" title="1.2 决策树与if-then规则"></a>1.2 决策树与if-then规则</h3><p>可将决策树看成一个if-then规则的集合，重要性质：互斥且完备，每一个实例有且只被一条路径或规则覆盖。</p>
<h3 id="1-2-决策树与条件概率分布"><a href="#1-2-决策树与条件概率分布" class="headerlink" title="1.2 决策树与条件概率分布"></a>1.2 决策树与条件概率分布</h3><p>决策树还表示给定特征条件下类的条件概率分布。这一条件概率分布定义在特征空间的一个划分上。决策树的一条路径对应于划分中的一个单元。</p>
<h3 id="1-3-决策树学习"><a href="#1-3-决策树学习" class="headerlink" title="1.3 决策树学习"></a>1.3 决策树学习</h3><p>找到与训练数据矛盾较小且泛化能力好的决策树。损失函数：正则化的极大似然函数。</p>
<p>主要步骤：</p>
<ul>
<li>特征选择</li>
<li>决策树生成</li>
<li>决策树剪枝</li>
</ul>
<h2 id="2-特征选择"><a href="#2-特征选择" class="headerlink" title="2.特征选择"></a>2.特征选择</h2><p> 准则：信息增益/信息增益比</p>
<h3 id="2-1-信息增益"><a href="#2-1-信息增益" class="headerlink" title="2.1 信息增益"></a>2.1 信息增益</h3><p>熵：随机变量不确定程度。</p>
<p>设X为取有限个值的随机变量，概率分布为：$P\left(X=x_{i}\right)=p_{i}, \quad i=1,2, \cdots, n$<br>随机变量X的<strong>熵</strong>：$H(X)=H(p)=-\sum_{i=1}^{n} p_{i} \log p_{i}$<br>$H(p)$满足$0 \leqslant H(p) \leqslant \log n$</p>
<p><strong>条件熵</strong>$H(Y|X)$：已知随机变量X的条件下随机变量Y的不确定性，定义为X给定条件下Y的条件概率分布的熵对X的数学期望</p>
<script type="math/tex; mode=display">
H(Y | X)=\sum_{i=1}^{n} p_{i} H\left(Y | X=x_{i}\right) \\
p_i=P(X=x_i),i=1,2,\cdots,n</script><p>熵和条件熵中的概率由数据估计（特别是极大似然估计）得到，分别称为经验熵和经验条件熵。</p>
<p><strong>信息增益g(D,A)</strong>：特征A对训练集D信息增益为D的经验熵H(D)与特征A给定条件下D的经验条件熵H(D|A)之差：</p>
<script type="math/tex; mode=display">
g(D, A)=H(D)-H(D | A)</script><p>根据信息增益的特征选择方法：对训练集（或子集）D，计算其各个特征的信息增益，选择信息增益最大的特征。</p>
<h3 id="2-2-信息增益比"><a href="#2-2-信息增益比" class="headerlink" title="2.2 信息增益比"></a>2.2 信息增益比</h3><p><strong>信息增益比</strong>：特征A对训练集D信息增益比为其信息增益g(D,A)与D的经验熵H(D)之比：</p>
<script type="math/tex; mode=display">
g_{R}(D, A)=\frac{g(D, A)}{H(D)}</script><h2 id="3-决策树的生成"><a href="#3-决策树的生成" class="headerlink" title="3.决策树的生成"></a>3.决策树的生成</h2><h3 id="3-1-ID3算法"><a href="#3-1-ID3算法" class="headerlink" title="3.1 ID3算法"></a>3.1 ID3算法</h3><p>在决策树各个结点上应用信息增益准则选择特征，递归地构建决策树。ID3相当于用极大似然法进行概率模型的选择。</p>
<h3 id="3-2-C4-5算法"><a href="#3-2-C4-5算法" class="headerlink" title="3.2 C4.5算法"></a>3.2 C4.5算法</h3><p>过程与ID3算法相似，不同的是用信息增益比来选择特征。</p>
<h2 id="4-决策树的剪枝"><a href="#4-决策树的剪枝" class="headerlink" title="4.决策树的剪枝"></a>4.决策树的剪枝</h2><p>过程：从已生成的树上裁掉一些子树或叶结点，并将其根结点或父结点作为新的叶结点，从而简化分类树模型，极小化决策树整体的损失函数。</p>
<p>决策树学习的<strong>损失函数</strong>：$C_{\alpha}(T)=\sum_{t=1}^{|T|} N_{t} H_{t}(T)+\alpha|T|$<br>其中经验熵：$H_{t}(T)=-\sum_{k} \frac{N_{tk}}{N_{t}} \log \frac{N_{t k}}{N_{t}}$<br>将损失函数右端第一项记作：$C(T)==-\sum_{t=1}^{|T|} \sum_{k=1}^{K} N_{t k} \log \frac{N_{t k}}{N_{t}}$</p>
<p>此时有：$C_{\alpha}(T)=C(T)+\alpha|T|$</p>
<p>C(T)表示模型对训练数据的预测误差，即模型与训练数据的拟合程度，|T|表示模型复杂度，参数 $\alpha\geq0$ 控制两者之间的影响。较大的 $\alpha$ 促使选择较简单的模型。</p>
<h2 id="5-CART算法"><a href="#5-CART算法" class="headerlink" title="5.CART算法"></a>5.CART算法</h2><p>分类与回归树</p>
<ul>
<li>回归树：平方误差最小化准则</li>
<li>分类树：基尼指数最小化准则</li>
</ul>
<h3 id="5-1-分类树生成"><a href="#5-1-分类树生成" class="headerlink" title="5.1 分类树生成"></a>5.1 分类树生成</h3><p>（1）概率分布的<strong>基尼指数</strong>：$\operatorname{Gini}(p)=\sum_{k=1}^{K} p_{k}\left(1-p_{k}\right)=1-\sum_{k=1}^{K} p_{k}^{2}$<br>对于二类问题：$\operatorname{Gini}(p)=2p(1-p)$<br>给定样本集合D的基尼指数：$\operatorname{Gini}(D)=1-\sum_{k=1}^{K}\left(\frac{\left|C_{k}\right|}{|D|}\right)^{2}$，$C_k$为属于第k类的样本子集。</p>
<p>若样本集合D根据某一可能值a被分成$D_1$和$D_2$两部分，在特征A条件下，集合D的基尼指数为</p>
<script type="math/tex; mode=display">\operatorname{Gini}(D, A)=\frac{\left|D_{1}\right|}{|D|} \operatorname{Gini}\left(D_{1}\right)+\frac{\left|D_{2}\right|}{|D|} \operatorname{Gini}\left(D_{2}\right)</script><p>基尼指数Gini(D)表示集合D的不确定性，基尼指数Gini(D,A)表示经A=a分割后集合D的不确定性。基尼指数值越大，样本集合的不确定性也就越大。</p>
<div align="center">    
<img src="https://raw.githubusercontent.com/TommyMerlin/Image-Hosting/master/ML/%E4%BA%8C%E7%B1%BB%E5%88%86%E7%B1%BB%E4%B8%AD%E5%9F%BA%E5%B0%BC%E6%8C%87%E6%95%B0%E3%80%81%E7%86%B5%E4%B9%8B%E5%8D%8A%E5%92%8C%E5%88%86%E7%B1%BB%E8%AF%AF%E5%B7%AE%E7%8E%87%E7%9A%84%E5%85%B3%E7%B3%BB.png
" width="400" height="229" alt="图片名称" align="center">
<p>二类分类中基尼指数、熵之半和分类误差率的关系</p>
</div>

<h3 id="5-2-CART剪枝"><a href="#5-2-CART剪枝" class="headerlink" title="5.2 CART剪枝"></a>5.2 CART剪枝</h3><p>（1）首先从生成算法产生的决策树$T_0$底端开始不断剪枝，直到$T_0$的根结点，形成一个子树序列$\left\{T_{0}, T_{1}, \cdots, T_{n}\right\}$<br>（2）然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树.</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>统计学习方法</tag>
        <tag>监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法第二章—感知机</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>感知机——二类分类的线性分类模型</p>
<h2 id="1-感知机模型"><a href="#1-感知机模型" class="headerlink" title="1.感知机模型"></a>1.感知机模型</h2><p>输入空间（特征空间）为 $\mathcal{X}\subseteq R^n$，输出空间为 $\mathcal{Y}\subseteq \{+1,-1\}$，输入 $x\in\mathcal{X}$ 表示实例的特征向量，输出 $y\in\mathcal{Y}$ 表示实例的类别，输入到输出空间的函数：<br>$f(x)=\operatorname{sign}(w \cdot x+b)$ 称为感知机，其中w:权值，b:偏置</p>
<p>感知机几何解释：线性方程 $w\cdot x+b=0$ 对应于特征空间$R^n$中的一个超平面S，w为超平面的法向量，b为超平面的截距，S将特征空间分为两个部分，位于两部分的点分别被分为正、负两类。</p>
<div align="center">    
<img src="/机器学习/统计学习方法/统计学习方法第二章学习笔记/感知机模型.png" width="300" height="250" alt="图片名称" align="center">
<p>感知机模型</p>
</div>

<h2 id="2-感知机学习策略"><a href="#2-感知机学习策略" class="headerlink" title="2.感知机学习策略"></a>2.感知机学习策略</h2><h3 id="2-1-数据集的线性可分性"><a href="#2-1-数据集的线性可分性" class="headerlink" title="2.1 数据集的线性可分性"></a>2.1 数据集的线性可分性</h3><p>存在某个超平面S可将数据集的正实例点和负实例点完全正确地划分到S两侧即为线性可分。</p>
<h3 id="2-2-学习策略"><a href="#2-2-学习策略" class="headerlink" title="2.2 学习策略"></a>2.2 学习策略</h3><p>输入空间 $R^n$ 中任一点 $x_0$ 到超平面S的距离：$\frac{1}{|w|}\left|w \cdot x_{0}+b\right|$</p>
<p>误分类点 $x_i$到超平面S的距离：$-\frac{1}{|w|} y_{i}\left(w \cdot x_{i}+b\right)$</p>
<p>所有误分类点到超平面S的总距离：$-\frac{1}{|w|} \sum_{x_{i}\in M} y_{i}\left(w \cdot x_{i}+b\right)$</p>
<p>不考虑$\frac{1}{|w|}$即得到了感知机学习的损失函数（经验风险）：</p>
<p>$L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdot x_{i}+b\right) \quad$  (M：误分类点集合)</p>
<h2 id="3-感知机学习算法"><a href="#3-感知机学习算法" class="headerlink" title="3.感知机学习算法"></a>3.感知机学习算法</h2><h3 id="3-1学习算法原始形式"><a href="#3-1学习算法原始形式" class="headerlink" title="3.1学习算法原始形式"></a>3.1学习算法原始形式</h3><p>随机梯度下降法：<br>任选一个初始超平面$w_0、b_0$，每次选择一个误分类点 $y_{i}\left(w \cdot x_{i}+b\right) \leqslant 0$ 使其梯度下降。<br>$w \leftarrow w+\eta y_{i} x_{i}$<br>$b \leftarrow b+\eta y_{i}$</p>
<h3 id="3-2学习算法对偶形式"><a href="#3-2学习算法对偶形式" class="headerlink" title="3.2学习算法对偶形式"></a>3.2学习算法对偶形式</h3><p>通过$w \leftarrow w+\eta y_{i} x_{i}$，$b \leftarrow b+\eta y_{i}$逐步修改w,b，设修改n次，则w,b关于$(x_i,y_i)$的增量为$\alpha_iy_ix_i$和$\alpha_iy_i$，其中$\alpha_i=n_i\eta$，最终学到的w,b可表示为<br>$w=\sum_{i=1}^{N} \alpha_{i} y_{i} x_{i}$<br>$b=\sum_{i=1}^{N} \alpha_{i} y_{i}$</p>
<p>取初值$\alpha \leftarrow 0, \quad b \leftarrow 0$，训练集中选取数据$\left(x_{i}, y_{i}\right)$，如果$y_{i}\left(\sum_{j=1}^{N} \alpha_{j} y_{j} x_{j} \cdot x_{i}+b\right) \leqslant 0$<br>则 $\alpha_{i} \leftarrow \alpha_{i}+\eta$，$b \leftarrow b+\eta y_{i}$</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>统计学习方法</tag>
        <tag>监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法第四章—朴素贝叶斯法</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-朴素贝叶斯法的学习与分类"><a href="#1-朴素贝叶斯法的学习与分类" class="headerlink" title="1.朴素贝叶斯法的学习与分类"></a>1.朴素贝叶斯法的学习与分类</h2><h3 id="1-1-基本方法"><a href="#1-1-基本方法" class="headerlink" title="1.1 基本方法"></a>1.1 基本方法</h3><p>输入空间$\mathcal{X} \subseteq \mathbf{R}^{n}$，输出空间$\mathcal{Y}=\left\{c_{1},c_{2}, \cdots, c_{K}\right\}$，朴素贝叶斯法通过训练集学习联合概率分布$P(X, Y)$，具体地学习先验概率分布$P\left(Y=c_{k}\right)$和条件概率分布$P\left(X=x | Y=c_{k}\right)=P\left(X^{(1)}=x^{(1)}, \cdots, X^{(n)}=x^{(n)} | Y=c_{k}\right)$，进而得到联合概率分布$P(X, Y)$。<br>条件概率分布有指数量级的参数，难以估计，现做出<strong>条件独立性假设</strong>：<br>$\begin{aligned} P\left(X=x | Y=c_{k}\right) &amp;=P\left(X^{(1)}=x^{(1)}, \cdots, X^{(n)}=x^{(n)} | Y=c_{k}\right) \\ &amp;=\prod_{j=1}^{n} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right) \end{aligned}$</p>
<p>即用于分类的特征在类确定的条件下都是条件独立的。</p>
<p><strong>基本公式（后验概率）</strong>：$P\left(Y=c_{k} | X=x\right)=\frac{P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)}{\sum_{k} P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)}$</p>
<p>分母对所有$c_k$都相同，所以可得朴素贝叶斯分类器：</p>
<script type="math/tex; mode=display">y=\arg \max _{c_{k}} P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)</script><h3 id="1-2-后验概率最大化的含义"><a href="#1-2-后验概率最大化的含义" class="headerlink" title="1.2 后验概率最大化的含义"></a>1.2 后验概率最大化的含义</h3><p>朴素贝叶斯法将实例分到后验概率最大的类中，这等价于期望风险最小化。</p>
<h2 id="2-参数估计"><a href="#2-参数估计" class="headerlink" title="2.参数估计"></a>2.参数估计</h2><h3 id="2-1-极大似然估计"><a href="#2-1-极大似然估计" class="headerlink" title="2.1 极大似然估计"></a>2.1 极大似然估计</h3><p>先验概率$P(Y=c_k)$的极大似然估计为</p>
<script type="math/tex; mode=display">P\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}{N}, \quad k=1,2, \cdots, K</script><p>第j个特征$x^{(j)}$可能取值的范围$\left\{a_{j 1}, a_{j 2}, \cdots, a_{j s_j}\right\}$，条件概率$P\left(X^{(j)}=a_{jl} | Y=c_{k}\right)$的极大似然估计是</p>
<p>$P\left(X^{(j)}=a_{j l} | Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(j)}=a_{j l}, y_{i}=c_{k}\right)}{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}$<br>$j=1,2, \cdots, n ; \quad l=1,2, \cdots, S_{j} ; \quad k=1,2, \cdots, K$<br>式中，$x_i^{(j)}$是第i个样本的第j个特征；$a_{jl}$是第j个特征可能取的第l个值；I为指示函数。</p>
<h3 id="2-2-学习与分类算法"><a href="#2-2-学习与分类算法" class="headerlink" title="2.2 学习与分类算法"></a>2.2 学习与分类算法</h3><p>（1）计算先验概率及条件概率</p>
<script type="math/tex; mode=display">\begin{aligned} &P\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}{N}, k=1,2, \cdots, K \\ 
&P\left(X^{(j)} =a_{j l} | Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(j)}=a_{j l}, y_{i}=c_{k}\right)}{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)} \\ 
&j=1,2, \cdots, n ; \quad l=1,2, \cdots, S_{j} ; \quad k=1,2, \cdots, K \end{aligned}</script><p>（2）对于实例$x=\left(x^{(1)}, x^{(2)}, \cdots, x^{(n)}\right)^{\mathrm{T}}$，计算</p>
<script type="math/tex; mode=display">P\left(Y=c_{k}\right) \prod_{j=1}^{n} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right), \quad k=1,2, \cdots, K</script><p>（3）确定实例x的类</p>
<script type="math/tex; mode=display">y=\arg \max _{c_{k}} P\left(Y=c_{k}\right) \prod_{j=1}^{n} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)</script><h3 id="2-3-贝叶斯估计"><a href="#2-3-贝叶斯估计" class="headerlink" title="2.3 贝叶斯估计"></a>2.3 贝叶斯估计</h3><p>条件概率的贝叶斯估计$P_{\lambda}\left(X^{(j)}=a_{j l} | Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(j)}=a_{j l}, y_{i}=c_{k}\right)+\lambda}{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)+S_{j} \lambda}$</p>
<p>$\lambda\geq0$，等价于在随机变量各个取值的频数上赋予一个正数$\lambda\gt0$，当$\lambda=0$即为极大似然估计，常取$\lambda=1$（拉普拉斯平滑）。</p>
<p>先验概率的贝叶斯估计：$P_{\lambda}\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)+\lambda}{N+K \lambda}$</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>统计学习方法</tag>
        <tag>监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法第一章—概论</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-统计学习"><a href="#1-统计学习" class="headerlink" title="1.统计学习"></a>1.统计学习</h2><h3 id="1-1特点"><a href="#1-1特点" class="headerlink" title="1.1特点"></a>1.1特点</h3><ul>
<li>建立于计算机及网络之上</li>
<li>数据驱动</li>
<li>目的：对数据进行预测及分析</li>
<li>以方法为中心</li>
<li>综合概率论、统计学、信息论、计算理论、最优化理论及计算机科学</li>
</ul>
<blockquote>
<p>统计学习就是计算机系统通过运用数据及统计方法提高系统性能的机器学习。</p>
</blockquote>
<h3 id="1-2对象"><a href="#1-2对象" class="headerlink" title="1.2对象"></a>1.2对象</h3><p> 统计学习对象：数据<br> <strong>基本假设：</strong> 同类数据具有一定的统计规律性</p>
<h3 id="1-3目的"><a href="#1-3目的" class="headerlink" title="1.3目的"></a>1.3目的</h3><p> 对<strong>新数据</strong>进行预测和分析</p>
<h3 id="1-4方法"><a href="#1-4方法" class="headerlink" title="1.4方法"></a>1.4方法</h3><p>常用方法：</p>
<ul>
<li>监督学习（supervised learning）</li>
<li>非监督学习（unsupervised learning）</li>
<li>半监督学习（semi-supervised learning）</li>
<li>强化学习（reinforcement learning）</li>
</ul>
<p>三要素：</p>
<ul>
<li>模型（model）</li>
<li>策略（strategy）</li>
<li>算法（algorithm）</li>
</ul>
<p>主要步骤：</p>
<ol>
<li>得到一个有限训练数据集</li>
<li>确定包含所有可能模型的假设空间（学习模型的集合）</li>
<li>确定模型选择的准则（学习策略）</li>
<li>实现求解最优模型的算法（学习算法）</li>
<li>通过学习算法选择最优模型</li>
<li>对新数据进行预测和分析</li>
</ol>
<h2 id="2监督学习基本概念"><a href="#2监督学习基本概念" class="headerlink" title="2监督学习基本概念"></a>2监督学习基本概念</h2><h3 id="2-1输入空间、特征空间、输出空间"><a href="#2-1输入空间、特征空间、输出空间" class="headerlink" title="2.1输入空间、特征空间、输出空间"></a>2.1输入空间、特征空间、输出空间</h3><ul>
<li>输入空间：输入的所有可能取值</li>
<li>输出空间：输出的所有可能取值</li>
<li>特征空间：所有特征向量存在空间</li>
<li>特征向量：表示具体的实例</li>
</ul>
<h3 id="2-2联合概率分布"><a href="#2-2联合概率分布" class="headerlink" title="2.2联合概率分布"></a>2.2联合概率分布</h3><p>监督学习假设输入与输出的随机变量X和Y遵循联合概率分布P(X,Y)  （基本假设）</p>
<h3 id="2-3假设空间"><a href="#2-3假设空间" class="headerlink" title="2.3假设空间"></a>2.3假设空间</h3><p>假设空间：输入空间到输出空间的映射的集合</p>
<h2 id="3-统计学习三要素"><a href="#3-统计学习三要素" class="headerlink" title="3 统计学习三要素"></a>3 统计学习三要素</h2><p>方法=模型+策略+算法</p>
<h3 id="3-1模型"><a href="#3-1模型" class="headerlink" title="3.1模型"></a>3.1模型</h3><p><strong>假设空间$\mathcal{F}$</strong></p>
<p>1）假设空间定义为<strong>决策函数</strong>的集合（非概率模型）</p>
<p>$\mathcal{F}=\{f|Y=f(X)\}$</p>
<p>X/Y：定义在输入空间$\mathcal{X}$和输出空间$\mathcal{Y}$上的随机变量，<br>此时$\mathcal{F}$通常是由一个参数向量决定的函数族：</p>
<p>$\mathcal{F}=\{f|Y=f_\theta(X),\theta \in R^n\}$</p>
<p>2）假设空间定义为<strong>条件概率</strong>的集合（概率模型）</p>
<p>$\mathcal{F}=\{P|P(X,Y)\}$</p>
<p>X/Y：定义在输入空间$\mathcal{X}$和输出空间$\mathcal{Y}$上的随机变量，<br>此时$\mathcal{F}$通常是由一个参数向量决定的条件概率分布族：</p>
<p>$\mathcal{F}=\{P|P_\theta(X,Y),\theta \in R^n\}$</p>
<h3 id="3-2策略"><a href="#3-2策略" class="headerlink" title="3.2策略"></a>3.2策略</h3><p>1）损失函数、风险函数<br>损失函数（代价函数）L(Y,f(X))：度量预测错误的程度，为f(X)和Y的非负实值函数</p>
<p>常用损失函数：</p>
<ul>
<li>0-1损失函数<br>$L(Y, f(X))=\left\{\begin{array}{ll}{1,} &amp; {Y \neq f(X)} \\ {0,} &amp; {Y=f(X)}\end{array}\right.$</li>
<li>平方损失函数<br>$L(Y, f(X))=(Y-f(X))^{2}$</li>
<li>绝对损失函数<br>$L(Y, f(X))=|Y-f(X)|$</li>
<li>对数损失函数/对数似然损失函数<br>$L(Y, P(Y | X))=-\log P(Y | X)$</li>
</ul>
<p>风险函数/期望损失$R_{\mathrm{exp}}(f)$：损失函数的期望<br>$R_{\mathrm{exp}}(f)=E_{P}[L(Y, f(X))]=\int_{\mathcal{X}\times\mathcal{Y}} L(y, f(x)) P(x, y) \mathrm{d} x \mathrm{d} y$</p>
<p>经验风险/经验损失$R_{\mathrm{emp}}(f)$：f(X)关于训练数据集的平均损失<br>$R_{\mathrm{emp}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)$</p>
<p>当N趋于无穷，经验风险$R_{\mathrm{emp}}(f)$趋于期望风险$R_{\mathrm{exp}}(f)$。</p>
<p>2）经验风险最小化与结构风险最小化</p>
<p><strong>经验风险最小化</strong>：经验风险最小的模型即为最优模型，求解如下最优化问题：</p>
<p>$\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)$</p>
<p>注意点：</p>
<ul>
<li>样本容量大效果好，如极大似然估计</li>
<li>样本容量小有可能产生“过拟合”现象</li>
</ul>
<p><strong>结构风险最小化</strong>：等价于正则化，防止过拟合。在经验风险上加上正则化项或罚项。</p>
<p>结构风险：$R_{sm}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)$</p>
<p>注意点：</p>
<ul>
<li>结构风险小需要经验风险与模型复杂度同时小</li>
<li>结构风险小对训练数据和测试数据都有较好的预测，如最大后验概率估计</li>
</ul>
<h3 id="3-3算法"><a href="#3-3算法" class="headerlink" title="3.3算法"></a>3.3算法</h3><p>学习模型的具体计算方法，也即求解最优化问题的算法</p>
<h2 id="4-模型评估与模型选择"><a href="#4-模型评估与模型选择" class="headerlink" title="4.模型评估与模型选择"></a>4.模型评估与模型选择</h2><h3 id="4-1-训练误差、测试误差"><a href="#4-1-训练误差、测试误差" class="headerlink" title="4.1 训练误差、测试误差"></a>4.1 训练误差、测试误差</h3><p>学习到的模型：$Y=\hat{f}(X)$</p>
<p>训练误差$R_{\mathrm{emp}}(\hat{f})$：模型$Y=\hat{f}(X)$关于训练集的平均损失：<br>$R_{\mathrm{emp}}(\hat{f})=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, \hat{f}\left(x_{i}\right)\right)$</p>
<p>测试误差$e_{\mathrm{test}}$：模型$Y=\hat{f}(X)$关于测试集的平均损失：<br>$e_{\mathrm{test}}=\frac{1}{N^{\prime}} \sum_{i=1}^{N^{\prime}} L\left(y_{i}, \hat{f}\left(x_{i}\right)\right)$</p>
<h3 id="4-2-模型选择"><a href="#4-2-模型选择" class="headerlink" title="4.2 模型选择"></a>4.2 模型选择</h3><p>避免出现过拟合并提高模型的预测能力</p>
<div align="center">    
<img src="/机器学习/统计学习方法/统计学习方法第一章学习笔记/M次多项式函数拟合问题.png" width="500" height="300" alt="图片名称" align="center">
<p>M次多项式函数拟合问题</p>
</div>

<div align="center">    
<img src="/机器学习/统计学习方法/统计学习方法第一章学习笔记/训练误差和测试误差与模型复杂度的关系.png" width="500" height="300" alt="图片名称" align="center">
<p>训练误差和测试误差与模型复杂度的关系</p>
</div>

<h2 id="5-正则化与交叉验证"><a href="#5-正则化与交叉验证" class="headerlink" title="5.正则化与交叉验证"></a>5.正则化与交叉验证</h2><h3 id="5-1-正则化"><a href="#5-1-正则化" class="headerlink" title="5.1 正则化"></a>5.1 正则化</h3><p>正则化项一般为模型复杂度的单调递增函数，模型越复杂，正则化值越大。</p>
<p>一般形式：$\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)$</p>
<p>正则化项不同形式：<br>$L_2范数$：$L(w)=\frac{1}{N} \sum_{i=1}^{N}\left(f\left(x_{i} ; w\right)-y_{i}\right)^{2}+\frac{\lambda}{2}|w|^{2}_2$<br>$L_1范数$：$L(w)=\frac{1}{N} \sum_{i=1}^{N}\left(f\left(x_{i} ; w\right)-y_{i}\right)^{2}+\lambda|w|_{1}$</p>
<ul>
<li>函数的p范数：$|w|_p=(\sum_{i=1}^{N}|x_i|^p)^{\frac{1}{p}}$ </li>
</ul>
<h3 id="5-2-交叉验证"><a href="#5-2-交叉验证" class="headerlink" title="5.2 交叉验证"></a>5.2 交叉验证</h3><p>1）简单交叉验证<br>随机将数据集分为两部分：训练集—测试集。</p>
<p>2）S折交叉验证<br>随机将数据切分成S个互不相交的同大小子集，训练集（S-1）—测试集（剩余子集）。</p>
<p>3）留一交叉验证<br>S折交叉验证特殊情形：S=N（N：数据集容量），缺乏数据情况下使用。</p>
<h2 id="6-泛化能力"><a href="#6-泛化能力" class="headerlink" title="6.泛化能力"></a>6.泛化能力</h2><p>学习到的模型：$Y=\hat{f}(X)$<br>泛化误差：$R_{\mathrm{exp}}(\hat{f})=E_{P}[L(Y, \hat{f}(X))]=\int_{\mathcal{X}\times\mathcal{Y}} L(y, \hat{f}(x)) P(x, y) \mathrm{d} x \mathrm{d} y$</p>
<h2 id="7-生成模型"><a href="#7-生成模型" class="headerlink" title="7.生成模型"></a>7.生成模型</h2><p>监督学习方法可分为生成方法和判别方法。</p>
<p>生成模型：朴素贝叶斯方法、隐马尔可夫模型<br>特点：</p>
<ul>
<li>可还原出联合概率分布P(X,Y)</li>
<li>学习收敛速度更快</li>
<li>存在隐变量，只能使用生成方法</li>
</ul>
<p>判别模型：k近邻法、感知机、决策树、逻辑斯蒂回归模型、最大熵模型、支持向量机、提升方法、条件随机场<br>特点：</p>
<ul>
<li>不可还原出联合概率分布P(X,Y)</li>
<li>学习准确率更高</li>
<li>可以简化学习问题</li>
</ul>
<h2 id="8-分类问题"><a href="#8-分类问题" class="headerlink" title="8.分类问题"></a>8.分类问题</h2><p>评价指标：分类准确率</p>
<p>二类问题常用评价指标：精确率、召回率<br>TP——将正类预测为正类数（正类：关注的类）<br>FN——将正类预测为负类数<br>FP——将负类预测为正类数<br>TN——将负类预测为负类数<br>精确率：$P=\frac{TP}{TP+FP}$<br>召回率：$R=\frac{TP}{TP+FN}$<br>$F_1$值：$\frac{2}{F_1}=\frac{1}{P}+\frac{1}{R}\quad\quad$$F_1=\frac{2TP}{2TP+FP+FN}$ （精确率、召回率的调和均值）</p>
<h2 id="9-标注问题"><a href="#9-标注问题" class="headerlink" title="9.标注问题"></a>9.标注问题</h2><p>输入：观测序列<br>输出：标记序列/状态序列<br>常用方法：隐马尔可夫模型、条件随机场</p>
<h2 id="10-回归问题"><a href="#10-回归问题" class="headerlink" title="10.回归问题"></a>10.回归问题</h2><p>回归模型：从输入变量到输出变量之间映射的函数，等价于函数拟合。<br>常用损失函数：平方损失函数，此时可由最小二乘法求解。</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法第三章—k近邻法</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="统计学习方法第三章—k近邻法"><a href="#统计学习方法第三章—k近邻法" class="headerlink" title="统计学习方法第三章—k近邻法"></a>统计学习方法第三章—k近邻法</h2><h3 id="1-k近邻算法"><a href="#1-k近邻算法" class="headerlink" title="1.k近邻算法"></a>1.k近邻算法</h3><p>给定训练集，对新的输入实例，在训练集中找到与该实例最邻近的k个实例，把该实例归入到这k个实例的多数属于的类。</p>
<h3 id="2-k近邻模型"><a href="#2-k近邻模型" class="headerlink" title="2.k近邻模型"></a>2.k近邻模型</h3><h4 id="2-1-距离度量：实例点间相似程度的反映。"><a href="#2-1-距离度量：实例点间相似程度的反映。" class="headerlink" title="2.1 距离度量：实例点间相似程度的反映。"></a>2.1 距离度量：实例点间相似程度的反映。</h4><p>$x_i,x_j$的$L_p$距离：$L_{p}\left(x_{i}, x_{j}\right)=\left(\sum_{i=1}^{n}\left|x_{i}^{(i)}-x_{j}^{(n)}\right|^{p}\right)^{\frac{1}{p}}$<br>p=2，欧式距离：$L_{2}\left(x_{i}, x_{j}\right)=\left(\sum_{i=1}^{n}\left|x_{i}^{(n)}-x_{j}^{(n)}\right|^{2}\right)^{\frac{1}{2}}$<br>p=1，曼哈顿距离：$L_{1}\left(x_{i}, x_{j}\right)=\sum_{l=1}^{n}\left|x_{i}^{(l)}-x_{j}^{(l)}\right|$<br>p=$\infty$，各坐标距离最大值：$L_{\infty}\left(x_{i}, x_{j}\right)=\max _{l}\left|x_{i}^{(l)}-x_{j}^{(l)}\right|$</p>
<h4 id="2-2-k值的选择"><a href="#2-2-k值的选择" class="headerlink" title="2.2 k值的选择"></a>2.2 k值的选择</h4><p>较小k值：近似误差减小，估计误差增大，预测结果对近邻的实例点非常敏感，模型复杂，易过拟合。<br>较大k值：估计误差减小，近似误差增大，模型简单。</p>
<p>k值一般取比较小的数值，采用交叉验证法选取最优k值。</p>
<h4 id="2-3-分类决策规则"><a href="#2-3-分类决策规则" class="headerlink" title="2.3 分类决策规则"></a>2.3 分类决策规则</h4><p>核心思想：多数表决</p>
<h3 id="3-k近邻法实现：kd树"><a href="#3-k近邻法实现：kd树" class="headerlink" title="3.k近邻法实现：kd树"></a>3.k近邻法实现：kd树</h3><p>kd树是二叉树，表示对k维空间的一个划分，构造过程相当于不断用垂直于坐标轴的超平面将k维空间切分，构成一系列k维超矩形区域，kd树每个结点对应于一个k维超矩形区域。<br>例：给定二维空间数据集$T=\left\{(2,3)^{\mathrm{T}},(5,4)^{\mathrm{T}},(9,6)^{\mathrm{T}},(4,7)^{\mathrm{T}},(8,1)^{\mathrm{T}},(7,2)^{\mathrm{T}}\right\}$，构造一个平衡kd树。</p>
<div align="center">    
<img src="https://raw.githubusercontent.com/TommyMerlin/Image-Hosting/master/%E6%9E%84%E9%80%A0kd%E6%A0%91.png" width="300" height="250" alt="图片名称" align="center">
<p>特征空间切分</p>
</div>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>统计学习方法</tag>
        <tag>监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub 项目精选</title>
    <url>/%E6%B1%87%E6%80%BB/GitHub%E9%A1%B9%E7%9B%AE%E7%B2%BE%E9%80%89/</url>
    <content><![CDATA[<p><img src="https://gitee.com/TommyMerlin/image-host-gitee/raw/master/pilot.jpg" alt><br><em>A collection of useful repositories.</em></p>
<hr>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><ol>
<li><a href="https://github.com/apachecn/AiLearning" target="_blank" rel="noopener">apachecn / AiLearning</a><blockquote>
<p>AiLearning: 机器学习 - MachineLearning - ML、深度学习 - DeepLearning - DL、自然语言处理 NLP。<br>网站: <a href="http://ailearning.apachecn.org" target="_blank" rel="noopener">http://ailearning.apachecn.org</a></p>
</blockquote>
</li>
<li><a href="https://github.com/datawhalechina/pumpkin-book" target="_blank" rel="noopener">datawhalechina / pumpkin-book</a><blockquote>
<p>《机器学习》（西瓜书）公式推导解析，在线阅读地址：<a href="https://datawhalechina.github.io/pumpkin-book" target="_blank" rel="noopener">https://datawhalechina.github.io/pumpkin-book</a></p>
</blockquote>
</li>
<li><a href="https://github.com/scutan90/DeepLearning-500-questions" target="_blank" rel="noopener">scutan90 / DeepLearning-500-questions</a><blockquote>
<p>深度学习500问，以问答形式对常用的概率知识、线性代数、机器学习、深度学习、计算机视觉等热点问题进行阐述。</p>
</blockquote>
</li>
<li><a href="https://github.com/zergtant/pytorch-handbook" target="_blank" rel="noopener">zergtant / pytorch-handbook</a><blockquote>
<p>pytorch handbook是一本开源的书籍，目标是帮助那些希望和使用PyTorch进行深度学习开发和研究的朋友快速入门，其中包含的Pytorch教程全部通过测试保证可以成功运行。</p>
</blockquote>
</li>
<li><a href="https://github.com/fengdu78/lihang-code" target="_blank" rel="noopener">fengdu78 / lihang-code</a><blockquote>
<p>《统计学习方法》的代码实现。</p>
</blockquote>
</li>
<li><a href="https://github.com/MLEveryday/100-Days-Of-ML-Code" target="_blank" rel="noopener">MLEveryday / 100-Days-Of-ML-Code</a><blockquote>
<p>100-Days-Of-ML-Code中文版。</p>
</blockquote>
</li>
<li><a href="https://github.com/GokuMohandas/practicalAI" target="_blank" rel="noopener">GokuMohandas / practicalAI</a><blockquote>
<p>A practical approach to machine learning.</p>
</blockquote>
</li>
<li><a href="https://github.com/roboticcam/machine-learning-notes" target="_blank" rel="noopener">roboticcam/machine-learning-notes</a><blockquote>
<p>不间断更新机器学习，概率模型和深度学习的讲义(1000+页)和视频链接。</p>
</blockquote>
</li>
<li><a href="https://github.com/afshinea/stanford-cs-229-machine-learning" target="_blank" rel="noopener">afshinea / stanford-cs-229-machine-learning</a><blockquote>
<p>VIP cheatsheets for Stanford’s CS 229 Machine Learning.<br>网站: <a href="https://stanford.edu/~shervine/teaching/cs-229" target="_blank" rel="noopener">https://stanford.edu/~shervine/teaching/cs-229</a></p>
</blockquote>
</li>
<li><a href="https://github.com/fengdu78/deeplearning_ai_books" target="_blank" rel="noopener">fengdu78 / deeplearning_ai_books</a><blockquote>
<p>deeplearning.ai（吴恩达老师的深度学习课程笔记及资源）。</p>
</blockquote>
</li>
<li><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">fengdu78 / Coursera-ML-AndrewNg-Notes</a><blockquote>
<p>吴恩达老师的机器学习课程个人笔记。</p>
</blockquote>
</li>
<li><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">tensorflow / tensorflow</a><blockquote>
<p>An Open Source Machine Learning Framework for Everyone.</p>
</blockquote>
</li>
<li><a href="https://github.com/d2l-ai/d2l-zh" target="_blank" rel="noopener">d2l-ai / d2l-zh</a><blockquote>
<p>《动手学深度学习》：面向中文读者、能运行、可讨论。英文版即伯克利“深度学习导论（STAT 157）”教材。<br>视频：<a href="https://space.bilibili.com/209599371/channel/detail?cid=23541" target="_blank" rel="noopener">https://space.bilibili.com/209599371/channel/detail?cid=23541</a><br>PDF: <a href="https://github.com/TommyMerlin/Repository-Collection/tree/master/files" target="_blank" rel="noopener">https://github.com/TommyMerlin/Repository-Collection/tree/master/files</a></p>
</blockquote>
</li>
<li><a href="https://github.com/afshinea/stanford-cs-229-machine-learning" target="_blank" rel="noopener">afshinea / stanford-cs-229-machine-learning</a><blockquote>
<p>Cheatsheets for Stanford’s CS 229 Machine Learning.</p>
</blockquote>
</li>
<li><a href="https://github.com/microsoft/ai-edu" target="_blank" rel="noopener">microsoft / ai-edu</a><blockquote>
<p>AI education materials for Chinese students, teachers and IT professionals.</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ol>
<li><a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">jackfrued / Python-100-Days</a><blockquote>
<p>Python - 100天从新手到大师。</p>
</blockquote>
</li>
<li><a href="https://github.com/TheAlgorithms/Python" target="_blank" rel="noopener">TheAlgorithms / Python</a><blockquote>
<p>算法的Python实现。All Algorithms implemented in Python.</p>
</blockquote>
</li>
<li><a href="https://github.com/vinta/awesome-python" target="_blank" rel="noopener">vinta / awesome-python</a><blockquote>
<p>A curated list of awesome Python frameworks, libraries, software and resources.<br>网站: <a href="https://awesome-python.com/" target="_blank" rel="noopener">https://awesome-python.com/</a></p>
</blockquote>
</li>
<li><a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">fxsjy / jieba</a><blockquote>
<p>结巴中文分词。</p>
</blockquote>
</li>
<li><a href="https://github.com/lancopku/pkuseg-python" target="_blank" rel="noopener">lancopku / pkuseg-python</a><blockquote>
<p>pkuseg多领域中文分词工具。</p>
</blockquote>
</li>
<li><a href="https://github.com/fighting41love/funNLP" target="_blank" rel="noopener">fighting41love / funNLP</a><blockquote>
<p>中英文敏感词、语言检测、中外手机/电话归属地/运营商查询、名字推断性别、手机号抽取、身份证抽取、邮箱抽取、中日文人名库、中文缩写库、拆字词典、词汇情感值、停用词、反动词表、暴恐词表、繁简体转换、英文模拟中文发音、汪峰歌词生成器、职业名称词库、同义词库、反义词库、否定词库、汽车品牌词库、汽车零件词库、连续英文切割、各种中文词向量、公司名字大全、古诗词库、IT词库、财经词库、成语词库、地名词库、历史名人词库、诗词词库、医学词库、饮食词库、法律词库、汽车词库、动物词库、中文聊天语料、中文谣言数据、百度中文问答数据集、句子相似度匹配算法集合、bert资源、文本生成&amp;摘要相关工具、cocoNLP信息抽取工具、国内电话号码正则匹配</p>
</blockquote>
</li>
<li><a href="https://github.com/amueller/word_cloud" target="_blank" rel="noopener">amueller / word_cloud</a><blockquote>
<p>词云生成。A little word cloud generator in Python.<br>网站: <a href="https://amueller.github.io/word_cloud" target="_blank" rel="noopener">https://amueller.github.io/word_cloud</a></p>
</blockquote>
</li>
<li><a href="https://github.com/jakevdp/PythonDataScienceHandbook" target="_blank" rel="noopener">jakevdp / PythonDataScienceHandbook</a><blockquote>
<p>Python数据处理。Python Data Science Handbook: full text in Jupyter Notebooks.</p>
</blockquote>
</li>
<li><a href="https://github.com/xchaoinfo/fuck-login" target="_blank" rel="noopener">xchaoinfo / fuck-login</a><blockquote>
<p>模拟登录一些知名的网站，为了方便爬取需要登录的网站。</p>
</blockquote>
</li>
<li><a href="https://github.com/fluentpython/example-code" target="_blank" rel="noopener">fluentpython / example-code</a><blockquote>
<p>《流畅的Python》书中代码。Example code for the book Fluent Python.</p>
</blockquote>
</li>
<li><a href="https://github.com/leisurelicht/wtfpython-cn" target="_blank" rel="noopener">leisurelicht / wtfpython-cn</a><blockquote>
<p>wtfpython的中文翻译。</p>
</blockquote>
</li>
<li><a href="https://github.com/qxf2/wtfiswronghere" target="_blank" rel="noopener">qxf2 / wtfiswronghere</a><blockquote>
<p>新手常犯的Python错误。<br>A collection of simple errors that beginners are likely to hit when they start writing Python.</p>
</blockquote>
</li>
<li><a href="https://github.com/rougier/matplotlib-cheatsheet" target="_blank" rel="noopener">rougier / matplotlib-cheatsheet</a><blockquote>
<p>Matplotlib 3.1 cheat sheet. From an upcoming book on matplotlib.</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ol>
<li><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">Snailclimb / JavaGuide</a><blockquote>
<p>【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。<br>网站: <a href="https://gitee.com/SnailClimb/JavaGuide" target="_blank" rel="noopener">https://gitee.com/SnailClimb/JavaGuide</a></p>
</blockquote>
</li>
<li><a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">doocs / advanced-java</a><blockquote>
<p>😮 互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务、海量数据处理等领域知识，后端同学必看，前端同学也可学习。<br>网站: <a href="https://doocs.github.io/advanced-java" target="_blank" rel="noopener">https://doocs.github.io/advanced-java</a></p>
</blockquote>
</li>
<li><a href="https://github.com/xingshaocheng/architect-awesome" target="_blank" rel="noopener">xingshaocheng / architect-awesome</a><blockquote>
<p>后端架构师技术图谱。<br>网站: <a href="https://docs.justauth.whnb.wang/" target="_blank" rel="noopener">https://docs.justauth.whnb.wang/</a></p>
</blockquote>
</li>
<li><a href="https://github.com/crossoverJie/JCSprout" target="_blank" rel="noopener">crossoverJie / JCSprout</a><blockquote>
<p>👨‍🎓 Java Core Sprout : basic, concurrent, algorithm.<br>网站: <a href="https://crossoverjie.top/JCSprout" target="_blank" rel="noopener">https://crossoverjie.top/JCSprout</a></p>
</blockquote>
</li>
<li><a href="https://github.com/wuyouzhuguli/SpringAll" target="_blank" rel="noopener">wuyouzhuguli / SpringAll</a><blockquote>
<p>循序渐进，学习Spring Boot、Spring Boot &amp; Shiro、Spring Cloud、Spring Security &amp; Spring Security OAuth2，博客Spring系列源码。  </p>
</blockquote>
</li>
<li><a href="https://github.com/hollischuang/toBeTopJavaer" target="_blank" rel="noopener">hollischuang / toBeTopJavaer</a><blockquote>
<p>To Be Top Javaer - Java工程师成神之路。  </p>
</blockquote>
</li>
<li><a href="https://github.com/aalansehaiyang/technology-talk" target="_blank" rel="noopener">aalansehaiyang / technology-talk</a><blockquote>
<p>汇总java生态圈常用技术框架、开源中间件，系统架构、数据库、大公司架构案例、常用三方类库、项目管理、线上问题排查、个人成长、思考等知识。  </p>
</blockquote>
</li>
<li><a href="https://github.com/AobingJava/JavaFamily" target="_blank" rel="noopener">AobingJava / JavaFamily</a><blockquote>
<p>【互联网一线大厂面试+学习指南】进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务等领域知识。  </p>
</blockquote>
</li>
<li><a href="https://github.com/ZhongFuCheng3y/3y" target="_blank" rel="noopener">ZhongFuCheng3y / 3y</a><blockquote>
<p>📓从Java基础、JavaWeb基础到常用的框架再到面试题都有完整的教程，几乎涵盖了Java后端必备的知识点。</p>
</blockquote>
</li>
<li><a href="https://github.com/xkcoding/spring-boot-demo" target="_blank" rel="noopener">xkcoding / spring-boot-demo</a><blockquote>
<p>spring boot demo 是一个用来深度学习并实战 spring boot 的项目，目前总共包含 65 个集成demo，已经完成 53 个。 该项目已成功集成 actuator(监控)、admin(可视化监控)、logback(日志)、aopLog(通过AOP记录web请求日志)、统一异常处理(json级别和页面级别)、freemarker(模板引擎)、thymeleaf(模板引擎)、Beetl(模板引擎)、Enjoy(模板引擎)、JdbcTemplate(通用JDBC操作数据库)、JPA(强大的ORM框架)、mybatis(强大的ORM框架)、通用Mapper(快速操作Mybatis)、PageHelper(通用的Mybatis分页插件)……  </p>
</blockquote>
</li>
<li><a href="https://github.com/qiurunze123/miaosha" target="_blank" rel="noopener">qiurunze123 / miaosha</a><blockquote>
<p>⭐⭐⭐⭐秒杀系统设计与实现.互联网工程师进阶与分析🙋🐓  </p>
</blockquote>
</li>
<li><a href="https://github.com/alibaba/druid" target="_blank" rel="noopener">alibaba / druid</a><blockquote>
<p>阿里巴巴数据库事业部出品，为监控而生的数据库连接池。  </p>
</blockquote>
</li>
<li><a href="https://github.com/justauth/JustAuth" target="_blank" rel="noopener">justauth / JustAuth</a><blockquote>
<p>💯 史上最全的整合第三方登录的开源库。目前已支持Github、Gitee、微博、钉钉、百度、Coding、腾讯云开发者平台、OSChina、支付宝、QQ、微信、淘宝、Google、Facebook、抖音、领英、小米、微软、今日头条、Teambition、StackOverflow、Pinterest、人人、华为、企业微信、酷家乐、Gitlab、美团、饿了么和推特等第三方平台的授权登录。 Login, so easy!<br>网站: <a href="https://docs.justauth.whnb.wang/" target="_blank" rel="noopener">https://docs.justauth.whnb.wang/</a>  </p>
</blockquote>
</li>
<li><a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">alibaba / p3c</a><blockquote>
<p>Alibaba Java Coding Guidelines pmd implements and IDE plugin.</p>
</blockquote>
</li>
<li><a href="https://github.com/pingfangx/jetbrains-in-chinese" target="_blank" rel="noopener">pingfangx / jetbrains-in-chinese</a><blockquote>
<p>JetBrains 系列软件汉化包 关键字: Android Studio 3.5 汉化包 CLion 2019.3 汉化包 DataGrip 2019.3 汉化包 GoLand 2019.3 汉化包 IntelliJ IDEA 2019.3 汉化包 PhpStorm 2019.3 汉化包 PyCharm 2019.3 汉化包 Rider 2019.3 汉化包 RubyMine 2019.3 汉化包 WebStorm 2019.3 汉化包。   </p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="中国大学课程资源"><a href="#中国大学课程资源" class="headerlink" title="中国大学课程资源"></a>中国大学课程资源</h2><ol>
<li><a href="https://github.com/USTC-Resource/USTC-Course" target="_blank" rel="noopener">USTC-Resource / USTC-Course</a><blockquote>
<p>中国科学技术大学课程资源。<br>网站: <a href="https://ustc-resource.github.io/USTC-Course" target="_blank" rel="noopener">https://ustc-resource.github.io/USTC-Course</a></p>
</blockquote>
</li>
<li><a href="https://github.com/PKUanonym/REKCARC-TSC-UHT" target="_blank" rel="noopener">PKUanonym / REKCARC-TSC-UHT</a><blockquote>
<p>清华大学计算机系课程攻略。</p>
</blockquote>
</li>
<li><a href="https://github.com/lib-pku/libpku" target="_blank" rel="noopener">lib-pku / libpku</a><blockquote>
<p>北京大学课程资料。<br>网站: <a href="https://lib-pku.github.io/" target="_blank" rel="noopener">https://lib-pku.github.io/</a> </p>
</blockquote>
</li>
<li><a href="https://github.com/QSCTech/zju-icicles" target="_blank" rel="noopener">QSCTech / zju-icicles</a><blockquote>
<p>浙江大学课程攻略共享计划。<br>网站: <a href="https://qsctech.github.io/zju-icicles/" target="_blank" rel="noopener">https://qsctech.github.io/zju-icicles/</a></p>
</blockquote>
</li>
<li><a href="https://github.com/TheNetAdmin/zjuthesis" target="_blank" rel="noopener">TheNetAdmin / zjuthesis</a><blockquote>
<p>浙江大学毕业论文 Latex 模板。</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="C-DOTNET"><a href="#C-DOTNET" class="headerlink" title="C# DOTNET"></a>C# DOTNET</h2><ol>
<li><a href="https://github.com/TheAlgorithms/C-Sharp" target="_blank" rel="noopener">TheAlgorithms / C-Sharp</a><blockquote>
<p>算法的C#实现。All algorithms implemented in C#.</p>
</blockquote>
</li>
<li><a href="https://github.com/Live-Charts/Live-Charts" target="_blank" rel="noopener">Live-Charts / Live-Charts</a><blockquote>
<p>.NET下简单、灵活、可交互的图表。<br>Simple, flexible, interactive &amp; powerful charts, maps and gauges for .Net.</p>
</blockquote>
</li>
<li><a href="https://github.com/0xd4d/dnSpy" target="_blank" rel="noopener">0xd4d / dnSpy</a><blockquote>
<p>.NET调试和编译器。.NET debugger and assembly editor.</p>
</blockquote>
</li>
<li><a href="https://github.com/shimat/opencvsharp" target="_blank" rel="noopener">shimat / opencvsharp</a><blockquote>
<p>.NET框架下的OpenCV。.NET Framework wrapper for OpenCV.</p>
</blockquote>
</li>
<li><a href="https://github.com/dathlin/HslCommunication" target="_blank" rel="noopener">dathlin / HslCommunication</a><blockquote>
<p>工业物联网基础架构框架，专注于基础技术通信和跨平台、跨语言通信功能，实现多种主流PLC数据读写。<br>网站: <a href="http://www.hslcommunication.cn" target="_blank" rel="noopener">http://www.hslcommunication.cn</a></p>
</blockquote>
</li>
<li><a href="https://github.com/quozd/awesome-dotnet" target="_blank" rel="noopener">quozd / awesome-dotnet</a><blockquote>
<p>A collection of awesome .NET libraries, tools, frameworks and software.</p>
</blockquote>
</li>
<li><a href="https://github.com/microsoft/dotnet" target="_blank" rel="noopener">microsoft / dotnet</a><blockquote>
<p>This repo is the official home of .NET on GitHub. It’s a great starting point to find many .NET OSS projects from Microsoft and the community, including many that are part of the .NET Foundation.</p>
</blockquote>
</li>
<li><a href="https://github.com/yuzhengyang/Fork" target="_blank" rel="noopener">yuzhengyang / Fork</a><blockquote>
<p>C#工具包，C#工具类，常用方法，系统API，文件处理、加密解密、Winform美化（C# Tools）。</p>
</blockquote>
</li>
<li><a href="https://github.com/Jimmey-Jiang/Common.Utility" target="_blank" rel="noopener">Jimmey-Jiang / Common.Utility</a><blockquote>
<p>比较全面的c#帮助类，各种功能性代码。</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="WPF"><a href="#WPF" class="headerlink" title="WPF"></a>WPF</h2><ol>
<li><a href="https://github.com/MaterialDesignInXAML/MaterialDesignInXamlToolkit" target="_blank" rel="noopener">MaterialDesignInXAML / MaterialDesignInXamlToolkit</a><blockquote>
<p>Google’s Material Design in XAML &amp; WPF, for C# &amp; VB.Net.<br>网站: <a href="http://materialdesigninxaml.net/" target="_blank" rel="noopener">http://materialdesigninxaml.net/</a></p>
</blockquote>
</li>
<li><a href="https://github.com/MahApps/MahApps.Metro" target="_blank" rel="noopener">MahApps / MahApps.Metro</a><blockquote>
<p>A framework that allows developers to cobble together a Metro or Modern UI for their own WPF applications with minimal effort.<br>网站: <a href="https://mahapps.com" target="_blank" rel="noopener">https://mahapps.com</a></p>
</blockquote>
</li>
<li><a href="https://github.com/firstfloorsoftware/mui" target="_blank" rel="noopener">firstfloorsoftware / mui</a><blockquote>
<p>Modern UI for WPF.</p>
</blockquote>
</li>
<li><a href="https://github.com/xceedsoftware/wpftoolkit" target="_blank" rel="noopener">xceedsoftware / wpftoolkit</a><blockquote>
<p>All the controls missing in WPF. Over 1 million downloads.</p>
</blockquote>
</li>
<li><a href="https://github.com/microsoft/WPF-Samples" target="_blank" rel="noopener">microsoft / WPF-Samples</a><blockquote>
<p>Repository for WPF related samples.</p>
</blockquote>
</li>
<li><a href="https://github.com/Panuon/PanuonUI" target="_blank" rel="noopener">Panuon / PanuonUI</a><blockquote>
<p>一个好看精致、开源无限制使用的WPF控件库。</p>
</blockquote>
</li>
<li><a href="https://github.com/Panuon/PanuonUI.Silver" target="_blank" rel="noopener">Panuon / PanuonUI.Silver</a><blockquote>
<p>Panuon.UI optimized version. A beautiful wpf ui library using templates &amp; attached properties.</p>
</blockquote>
</li>
<li><a href="https://github.com/kwonganding/wpf.controls" target="_blank" rel="noopener">kwonganding / wpf.controls</a><blockquote>
<p>在学习中和使用WPF中，学习、借鉴了很多网友的文章和开源的项目的知识。发现提供实际项目开发需要的基础控件、样式的文章大都比较散，不成系列。因此基于现在项目中使用开发了一个wpf基础UI库。</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="前端-博客"><a href="#前端-博客" class="headerlink" title="前端/博客"></a>前端/博客</h2><ol>
<li><a href="https://github.com/qiu-deqing/FE-learning" target="_blank" rel="noopener">qiu-deqing / FE-learning</a><blockquote>
<p>前端入门方法。</p>
</blockquote>
</li>
<li><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">theme-next / hexo-theme-next</a><blockquote>
<p>Hexo主题。Elegant and powerful theme for Hexo.</p>
</blockquote>
</li>
<li><a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">gitalk / gitalk</a><blockquote>
<p>Gitalk is a modern comment component based on Github Issue and Preact.</p>
</blockquote>
</li>
<li><a href="https://github.com/helloqingfeng/Awsome-Front-End-learning-resource" target="_blank" rel="noopener">helloqingfeng / Awsome-Front-End-learning-resource</a><blockquote>
<p>GitHub最全的前端资源汇总仓库（包括前端学习、开发资源、求职面试等）。</p>
</blockquote>
</li>
<li><a href="https://github.com/kamranahmedse/developer-roadmap" target="_blank" rel="noopener">kamranahmedse / developer-roadmap</a><blockquote>
<p>Roadmap to becoming a web developer in 2019.</p>
</blockquote>
</li>
<li><a href="https://github.com/ProfessionalCSharp/ProfessionalCSharp6" target="_blank" rel="noopener">ProfessionalCSharp / ProfessionalCSharp6</a><blockquote>
<p>Code samples for the book Professional C# 6 and .NET Core 1.0, Wrox Press.</p>
</blockquote>
</li>
<li><a href="https://github.com/b3log/pipe" target="_blank" rel="noopener">b3log / pipe</a><blockquote>
<p>🎷 一款小而美的博客平台，专为程序员设计。</p>
</blockquote>
</li>
<li><a href="https://github.com/pandao/editor.md" target="_blank" rel="noopener">pandao / editor.md</a><blockquote>
<p>开源可嵌入的在线Markdown编辑器（模块）。The open source embeddable online markdown editor (component).<br>网站: <a href="http://editor.md.ipandao.com/" target="_blank" rel="noopener">http://editor.md.ipandao.com/</a></p>
</blockquote>
</li>
<li><a href="https://github.com/qianguyihao/Web" target="_blank" rel="noopener">qianguyihao / Web</a><blockquote>
<p>前端入门和进阶学习笔记，超详细的Web前端学习图文教程。</p>
</blockquote>
</li>
<li><a href="https://github.com/lydiahallie/javascript-questions" target="_blank" rel="noopener">lydiahallie / javascript-questions</a><blockquote>
<p>A long list of (advanced) JavaScript questions, and their explanations ✨  </p>
</blockquote>
</li>
<li><a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">EYHN / hexo-helper-live2d</a><blockquote>
<p>Add the Sseexxyyy live2d to your hexo!  </p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="资源汇总"><a href="#资源汇总" class="headerlink" title="资源汇总"></a>资源汇总</h2><ol>
<li><a href="https://github.com/sindresorhus/awesome" target="_blank" rel="noopener">sindresorhus / awesome</a><blockquote>
<p>Awesome lists about all kinds of interesting topics.</p>
</blockquote>
</li>
<li><a href="https://github.com/dipakkr/A-to-Z-Resources-for-Students" target="_blank" rel="noopener">dipakkr / A-to-Z-Resources-for-Students</a><blockquote>
<p>Curated list of resources for college students.</p>
</blockquote>
</li>
<li><a href="https://github.com/LisaDziuba/Awesome-Design-Tools" target="_blank" rel="noopener">LisaDziuba / Awesome-Design-Tools</a><blockquote>
<p>The best design tools for everything.</p>
</blockquote>
</li>
<li><a href="https://github.com/Solido/awesome-flutter" target="_blank" rel="noopener">Solido / awesome-flutter</a><blockquote>
<p>An awesome list that curates the best Flutter libraries, tools, tutorials, articles and more.</p>
</blockquote>
</li>
<li><a href="https://github.com/TonnyL/Awesome_APIs" target="_blank" rel="noopener">TonnyL / Awesome_APIs</a><blockquote>
<p>:octocat: A collection of APIs.</p>
</blockquote>
</li>
<li><a href="https://github.com/public-apis/public-apis" target="_blank" rel="noopener">public-apis / public-apis</a><blockquote>
<p>A collective list of free APIs for use in software and web development.</p>
</blockquote>
</li>
<li><a href="https://github.com/matiassingers/awesome-readme" target="_blank" rel="noopener">matiassingers / awesome-readme</a><blockquote>
<p>A curated list of awesome READMEs.</p>
</blockquote>
</li>
<li><a href="https://github.com/ryanoasis/nerd-fonts" target="_blank" rel="noopener">ryanoasis / nerd-fonts</a><blockquote>
<p>图标、字体集合。🔡 Iconic font aggregator, collection, and patcher. 40+ patched fonts, over 3,600 glyph/icons, includes popular collections such as Font Awesome &amp; fonts such as Hack.</p>
</blockquote>
</li>
<li><a href="https://github.com/justjavac/awesome-wechat-weapp" target="_blank" rel="noopener">justjavac / awesome-wechat-weapp</a><blockquote>
<p>微信小程序开发资源汇总 💯</p>
</blockquote>
</li>
<li><a href="https://github.com/521xueweihan/HelloGitHub" target="_blank" rel="noopener">521xueweihan / HelloGitHub</a><blockquote>
<p>Find pearls on open-source seashore 分享 GitHub 上有趣、入门级的开源项目。<br>网站: <a href="https://hellogithub.com/" target="_blank" rel="noopener">https://hellogithub.com/</a></p>
</blockquote>
</li>
<li><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts" target="_blank" rel="noopener">kon9chunkit / GitHub-Chinese-Top-Charts</a><blockquote>
<p>🇨🇳 GitHub中文排行榜，帮助你发现高分优秀中文项目、更高效地吸收国人的优秀经验成果；榜单每周更新一次，敬请关注！ </p>
</blockquote>
</li>
<li><a href="https://github.com/ruanyf/weekly" target="_blank" rel="noopener">ruanyf / weekly</a><blockquote>
<p>科技爱好者周刊，每周五发布。  </p>
</blockquote>
</li>
<li><a href="https://github.com/niezhiyang/open_source_team" target="_blank" rel="noopener">niezhiyang / open_source_team</a><blockquote>
<p>国内顶尖团队的开源地址。  </p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="CS相关"><a href="#CS相关" class="headerlink" title="CS相关"></a>CS相关</h2><ol>
<li><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">CyC2018 / CS-Notes</a><blockquote>
<p>📚 技术面试必备基础知识、Leetcode 题解、Java、C++、Python、后端面试、操作系统、计算机网络、系统设计。</p>
</blockquote>
</li>
<li><a href="https://github.com/prakhar1989/awesome-courses" target="_blank" rel="noopener">prakhar1989 / awesome-courses</a><blockquote>
<p>📚 大学CS课程。List of awesome university courses for learning Computer Science!</p>
</blockquote>
</li>
<li><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="noopener">EbookFoundation / free-programming-books</a><blockquote>
<p>📚 编程相关书籍。Freely available programming books.</p>
</blockquote>
</li>
<li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">justjavac / free-programming-books-zh_CN</a><blockquote>
<p>📚 免费的计算机编程类中文书籍</p>
</blockquote>
</li>
<li><a href="https://github.com/ruanyf/free-books" target="_blank" rel="noopener">ruanyf / free-books</a><blockquote>
<p>互联网上的免费书籍。</p>
</blockquote>
</li>
<li><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">Snailclimb / JavaGuide</a><blockquote>
<p>【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。</p>
</blockquote>
</li>
<li><a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">protocolbuffers / protobuf</a><blockquote>
<p>Protocol Buffers - Google’s data interchange format.</p>
</blockquote>
</li>
<li><a href="https://github.com/geeeeeeeeek/git-recipes" target="_blank" rel="noopener">geeeeeeeeek / git-recipes</a><blockquote>
<p>🥡 高质量的Git中文教程。Git recipes in Chinese by Zhongyi Tong.</p>
</blockquote>
</li>
<li><a href="https://github.com/github/gitignore" target="_blank" rel="noopener">github / gitignore</a><blockquote>
<p>A collection of useful .gitignore templates.</p>
</blockquote>
</li>
<li><a href="https://github.com/ziishaned/learn-regex" target="_blank" rel="noopener">ziishaned / learn-regex</a><blockquote>
<p>学习正则表达式。Learn regex the easy way.</p>
</blockquote>
</li>
<li><a href="https://github.com/Lellansin/Cipher-examples" target="_blank" rel="noopener">Lellansin / Cipher-examples</a><blockquote>
<p>常见加密算法。</p>
</blockquote>
</li>
<li><a href="https://github.com/badges/shields" target="_blank" rel="noopener">badges / shields</a><blockquote>
<p>Concise, consistent, and legible badges in SVG and raster format.<br>网站: <a href="https://shields.io/" target="_blank" rel="noopener">https://shields.io/</a></p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="AGV"><a href="#AGV" class="headerlink" title="AGV"></a>AGV</h2><ol>
<li><a href="https://github.com/AtsushiSakai/PythonRobotics" target="_blank" rel="noopener">AtsushiSakai / PythonRobotics</a><blockquote>
<p>Python sample codes for robotics algorithms.</p>
</blockquote>
</li>
<li><a href="https://github.com/anvaka/ngraph.path" target="_blank" rel="noopener">anvaka / ngraph.path</a><blockquote>
<p>Path finding in a graph.</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="有趣项目"><a href="#有趣项目" class="headerlink" title="有趣项目"></a>有趣项目</h2><ol>
<li><a href="https://github.com/chrislgarry/Apollo-11" target="_blank" rel="noopener">chrislgarry / Apollo-11</a><blockquote>
<p>阿波罗11号。Original Apollo 11 Guidance Computer (AGC) source code for the command and lunar modules.</p>
</blockquote>
</li>
<li><a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">hakimel / reveal.js</a><blockquote>
<p>The HTML Presentation Framework.</p>
</blockquote>
</li>
<li><a href="https://github.com/VincentSit/ChinaMobilePhoneNumberRegex" target="_blank" rel="noopener">VincentSit / ChinaMobilePhoneNumberRegex</a><blockquote>
<p> 一组匹配中国大陆手机号码的正则表达式。<br>Regular expressions that match the mobile phone number in mainland China.</p>
</blockquote>
</li>
<li><a href="https://github.com/Jannchie/Historical-ranking-data-visualization-based-on-d3.js" target="_blank" rel="noopener">Jannchie / Historical-ranking-data-visualization-based-on-d3.js</a><blockquote>
<p>这是一个数据可视化项目，能够将历史数据排名转化为动态柱状图图表。</p>
</blockquote>
</li>
<li><a href="https://github.com/pomber/git-history" target="_blank" rel="noopener">pomber / git-history</a><blockquote>
<p>可视化浏览commit历史。Quickly browse the history of a file from any git repository.<br>网站: <a href="https://githistory.xyz/" target="_blank" rel="noopener">https://githistory.xyz/</a></p>
</blockquote>
</li>
<li><a href="https://github.com/leon-ai/leon" target="_blank" rel="noopener">leon-ai / leon</a><blockquote>
<p>Leon is your open-source personal assistant.</p>
</blockquote>
</li>
<li><a href="https://github.com/lennylxx/ipv6-hosts" target="_blank" rel="noopener">lennylxx / ipv6-hosts</a><blockquote>
<p>Fork of <a href="https://code.google.com/archive/p/ipv6-hosts/" target="_blank" rel="noopener">https://code.google.com/archive/p/ipv6-hosts/</a>, focusing on automation.</p>
</blockquote>
</li>
<li><a href="https://github.com/chinese-poetry/chinese-poetry" target="_blank" rel="noopener">chinese-poetry / chinese-poetry</a><blockquote>
<p>最全中华古诗词数据库, 唐宋两朝近一万四千古诗人, 接近5.5万首唐诗加26万宋诗. 两宋时期1564位词人，21050首词。</p>
</blockquote>
</li>
<li><a href="https://github.com/JustArchiNET/ArchiSteamFarm" target="_blank" rel="noopener">JustArchiNET / ArchiSteamFarm</a><blockquote>
<p>Steam挂卡。C# application with primary purpose of idling Steam cards from multiple accounts simultaneously.</p>
</blockquote>
</li>
<li><a href="https://github.com/soimort/you-get" target="_blank" rel="noopener">soimort / you-get</a><blockquote>
<p>Dumb downloader that scrapes the web.</p>
</blockquote>
</li>
<li><a href="https://github.com/houshanren/hangzhou_house_knowledge" target="_blank" rel="noopener">houshanren / hangzhou_house_knowledge</a><blockquote>
<p>2017年买房经历总结出来的买房购房知识分享给大家，希望对大家有所帮助。买房不易，且买且珍惜。</p>
</blockquote>
</li>
<li><a href="https://github.com/komeiji-satori/Dress" target="_blank" rel="noopener">komeiji-satori / Dress</a><blockquote>
<p>好耶 是女装。</p>
</blockquote>
</li>
<li><a href="https://github.com/XX-net/XX-Net" target="_blank" rel="noopener">XX-net / XX-Net</a><blockquote>
<p>A web proxy tool.</p>
</blockquote>
</li>
<li><a href="https://github.com/Aniket965/Hello-world" target="_blank" rel="noopener">Aniket965 / Hello-world</a><blockquote>
<p>Add any Program in any language you like or add a hello world Program ❣️ if you like give us ⭐️.</p>
</blockquote>
</li>
<li><a href="https://github.com/rwv/chinese-dos-games" target="_blank" rel="noopener">rwv / chinese-dos-games</a><blockquote>
<p>🎮 Chinese DOS games in browser.</p>
</blockquote>
</li>
<li><a href="https://github.com/gelstudios/gitfiti" target="_blank" rel="noopener">gelstudios / gitfiti</a><blockquote>
<p>随意更改commit历史。Abusing github commit history for the lulz.</p>
</blockquote>
</li>
<li><a href="https://github.com/ornicar/lila" target="_blank" rel="noopener">ornicar / lila</a><blockquote>
<p>国际象棋。♞ lichess.org: the forever free, adless and open source chess server. ♞</p>
</blockquote>
</li>
<li><a href="https://github.com/cmiscm/leonsans" target="_blank" rel="noopener">cmiscm / leonsans</a><blockquote>
<p>代码生成的字体。Leon Sans is a geometric sans-serif typeface made with code in 2019 by Jongmin Kim.<br>网站: <a href="https://leon-kim.com/" target="_blank" rel="noopener">https://leon-kim.com/</a></p>
</blockquote>
</li>
<li><a href="https://github.com/menzi11/BullshitGenerator" target="_blank" rel="noopener">menzi11 / BullshitGenerator</a><blockquote>
<p>狗屁不通文章生成器。Needs to generate some texts to test if my GUI rendering codes good or not. so I made this.<br>网站: <a href="https://suulnnka.github.io/BullshitGenerator/index.html" target="_blank" rel="noopener">https://suulnnka.github.io/BullshitGenerator/index.html</a></p>
</blockquote>
</li>
<li><a href="https://github.com/3b1b/manim" target="_blank" rel="noopener">3b1b / manim</a><blockquote>
<p>数学动画引擎。Animation engine for explanatory math videos.</p>
</blockquote>
</li>
<li><a href="https://github.com/carloscuesta/gitmoji" target="_blank" rel="noopener">carloscuesta / gitmoji</a><blockquote>
<p>在commit信息中添加emoji。An emoji guide for your commit messages. 😜<br>网站: <a href="https://gitmoji.carloscuesta.me/" target="_blank" rel="noopener">https://gitmoji.carloscuesta.me/</a></p>
</blockquote>
</li>
<li><a href="https://github.com/shimohq/chinese-programmer-wrong-pronunciation" target="_blank" rel="noopener">shimohq / chinese-programmer-wrong-pronunciation</a><blockquote>
<p>中国程序员容易发音错误的单词。  </p>
</blockquote>
</li>
<li><a href="https://github.com/SkalskiP/make-sense" target="_blank" rel="noopener">SkalskiP / make-sense</a><blockquote>
<p>Free to use online tool for labelling photos.<br>网站: <a href="https://makesense.ai" target="_blank" rel="noopener">https://makesense.ai</a></p>
</blockquote>
</li>
<li><a href="https://github.com/A3M4/YouTube-Report" target="_blank" rel="noopener">A3M4 / YouTube-Report</a><blockquote>
<p>📊 Generate a personal YouTube report from your Google Takeout data  </p>
</blockquote>
</li>
<li><a href="https://github.com/CopyTranslator/CopyTranslator" target="_blank" rel="noopener">CopyTranslator / CopyTranslator</a><blockquote>
<p>Foreign language reading and translation assistant based on copy and translate.  </p>
</blockquote>
</li>
<li><a href="https://github.com/nondanee/UnblockNeteaseMusic" target="_blank" rel="noopener">nondanee / UnblockNeteaseMusic</a><blockquote>
<p>Revive unavailable songs for Netease Cloud Music.  </p>
</blockquote>
</li>
<li><a href="https://github.com/kelseyhightower/nocode" target="_blank" rel="noopener">kelseyhightower / nocode</a><blockquote>
<p>The best way to write secure and reliable applications. Write nothing; deploy nowhere.  </p>
</blockquote>
</li>
<li><a href="https://github.com/monicahq/monica" target="_blank" rel="noopener">monicahq / monica</a><blockquote>
<p>Personal CRM. Remember everything about your friends, family and business relationships.<br>网站: <a href="https://www.monicahq.com/" target="_blank" rel="noopener">https://www.monicahq.com/</a></p>
</blockquote>
</li>
</ol>
<p>Example</p>
<ol>
<li><a href="link">owner</a><blockquote>
<p>content<br>网站: <link></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>汇总</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 搭建个人博客网站美化</title>
    <url>/%E6%95%99%E7%A8%8B/Hexo-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<p>上一篇我们讲了个人博客网站的搭建和部署问题，这一篇我们来讲讲博客网站的美化。还是以 Next 主题为例，打开 <code>themes\next</code> 文件夹下的 <code>_config.yml</code> <strong>(注意不是根目录下的 <code>_config.yml</code> 文件)</strong>，这个文件就是 Next 主题的配置文件，在其中可以修改和主题相关的配置选项，模拟人生4 2019.05.22 Origin正版备份</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + GitHub 搭建个人博客</title>
    <url>/%E6%95%99%E7%A8%8B/Hexo-GitHub-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<div align="center">
    <img src="https://raw.githubusercontent.com/TommyMerlin/Image-Hosting/master/blog1-1.jpg" width="85%">
</div>

<p>对于程序员来说，搭建和维护一个个人博客十分必要​，写博客既是对所学知识的整理和总结，同时也能向他人展现自己的学习成果。这篇教程就是基于 Hexo 和 GitHub 来搭建属于自己的个人博客，简单快捷，对小白也十分友好。</p>
<hr>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>本次Hexo博客搭建环境</p>
<blockquote>
<p>Windows 10  1803<br>node-v10.14.1<br>git version 2.21.0.windows.1<br>hexo-v3.8.0</p>
</blockquote>
<p>安装各种依赖环境还是比较简单的，基本上就是从各自的官网下载进行安装，十分方便。</p>
<h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>Hexo 的运行需要 Node.js 的支持，所以我们需要首先安装好 Node.js 。打开<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js官网</a>就能很明显地看到下载提示，点击左边的按钮进行下载即可。</p>
<p><img src="https://raw.githubusercontent.com/TommyMerlin/Image-Hosting/master/blog1-2.jpg" width="75%"></p>
<p><strong>下载完点击安装程序进行安装，无需修改安装路径的话无脑点击下一步即可。</strong><br>当安装完成后打开命令行工具（cmd/powershell)，输入<code>node -v</code>，如果输出如下信息，安装即为成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v10.14.1</span><br></pre></td></tr></table></figure>
<h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><p>我们需要从 GitHub 上下载主题文件，最重要的是我们需要将本地的博客部署到可供外部访问的网页上去，我们借助的是 GitHub ，这些都离不开 Git 的支持。同样的我们到 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git官网下载页</a>下载即可。这里我们选择 Windows 64 位最新版本的 Git for Windows 进行安装。</p>
<p><img src="https://raw.githubusercontent.com/TommyMerlin/Image-Hosting/master/blog1-3.jpg" width="90%/"></p>
<p><strong>安装和 Node.js 差不多，不做修改的话一直点下一步即可。</strong><br>安装完成后同样打开命令行工具（cmd/powershell)，输入<code>git --version</code>，如果输出如下信息，安装即为成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">git version 2.21.0.windows.1</span><br></pre></td></tr></table></figure>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>安装完 Git 后，我们的操作就可以在 Git Bash 中进行<strong>(当然在其他命令行工具中也行)</strong>，在资源管理的任意目录下右键鼠标可以看到 Git Bash Here 选项。</p>
<p><img src="https://raw.githubusercontent.com/TommyMerlin/Image-Hosting/master/blog1-4.jpg" width="30%/"></p>
<p>单击该选项，我们便进入了 Git 的命令行工具界面如下(同样打开Windows自带的cmd或是其他命令行工具都可以)，之后 Hexo 的安装、博客的部署等操作都在这个界面进行。</p>
<p><img src="https://raw.githubusercontent.com/TommyMerlin/Image-Hosting/master/blog1-5.jpg" width="75%/"></p>
<p>由于国内的 npm 访问外网下载速度较慢，我们可以将 npm 源更换为淘宝的镜像（当然如果你觉得你的下载速度较快的话，也可以选择不进行更换），在 Git Bash 中输入以下指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p><strong>请注意如果进行了上述操作，那么之后的下载等操作需要使用到 npm 的地方你都应该更换为 cnpm 指令，这样才能起到加速作用，如果未进行更换，则使用 npm 即可。</strong></p>
<p>接下来就是重头戏<strong>安装 Hexo </strong>了。输入如下指令即可安装完成 Hexo 的安装，十分方便。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>在安装过程中可能会出现<code>WARN</code>提示，这是因为 Hexo 的某些内容不支持 Windows 系统，我们无需理会 <del>(程序员只关心 Error，不关心 Warning🙃)</del>。</p>
<p>安装完成后，我们输入 <code>hexo -v</code> 命令，如果显示如下信息，则安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Windows_NT 10.0.17134 win32 x64</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">node: 10.14.1</span><br><span class="line">v8: 6.8.275.32-node.36</span><br><span class="line">uv: 1.23.2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>底下还有许多包的版本信息，可以看到 Hexo 的依赖项还是比较多的。</p>
<hr>
<h1 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h1><p>在我们想要存放博客文件的盘下进入 Git Bash ，首先我们要新建一个文件夹用来存放我们写的博客和其它相关文件，在命令行中输入<code>mkdir Blog</code> 命令，便可新建一个名称为 Blog 的文件夹（文件夹名可自取）。接下来进入刚创建的文件夹，可使用 <code>cd Blog</code> 命令，或是进入该文件夹后在空白处单击右键，再点击 Git Bash Here （还是多练习以下命令行的简单命令为好）。</p>
<p>进入 Blog 文件夹后，输入 <code>hexo init</code> 命令，即可完成该文件夹的初始化，在此期间，Hexo 会自动克隆和创建一系列相关文件，在结束后为得到如下反馈：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">INFO  Cloning hexo-starter to F:\desktop\Blog</span><br><span class="line">Cloning into <span class="string">'F:\desktop\Blog'</span>...</span><br><span class="line">...</span><br><span class="line">Unpacking objects: 100% (71/71), <span class="keyword">done</span>.</span><br><span class="line">Submodule <span class="string">'themes/landscape'</span> (https://github.com/hexojs/hexo-theme-landscape.git) registered <span class="keyword">for</span> path <span class="string">'themes/landscape'</span></span><br><span class="line">Cloning into <span class="string">'F:/desktop/Blog/themes/landscape'</span>...</span><br><span class="line">...</span><br><span class="line">Receiving objects: 100% (890/890), 2.56 MiB | 362.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (465/465), <span class="keyword">done</span>.</span><br><span class="line">Submodule path <span class="string">'themes/landscape'</span>: checked out <span class="string">'73a23c51f8487cfcd7c6deec96ccc7543960d350'</span></span><br><span class="line">INFO  Install dependencies</span><br><span class="line">...</span><br><span class="line">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure>
<p>当看到 <code>Start blogging with Hexo</code> 就知道我们已经初始化成功了，Blog 文件夹中会创建如下文件：</p>
<p><img src="https://raw.githubusercontent.com/TommyMerlin/Image-Hosting/master/blog1-6.jpg" width="80%/"></p>
<hr>
<h1 id="生成博客页面"><a href="#生成博客页面" class="headerlink" title="生成博客页面"></a>生成博客页面</h1><p>在 \source\_posts\ 文件夹中就保存着我们写的所有博客，当前我们并没有写任何博客，但是 Hexo 为自动生成一个 hello-world.md 文件，我们可以以此为例，看看我们的博客网页是啥样啦。</p>
<p>在 Git Bash 中输入 <code>hexo g</code> 命令（是 <code>hexo generate</code> 的简写），等待 Hexo 自动生成网页，得到如下反馈则生成成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded <span class="keyword">in</span> 192 ms</span><br><span class="line">INFO  Generated: index.html</span><br><span class="line">...</span><br><span class="line">INFO  28 files generated <span class="keyword">in</span> 459 ms</span><br></pre></td></tr></table></figure>
<p>接下来我们需要开启开启本地服务器，输入 <code>hexo s</code> 命令（是 <code>hexo server</code> 的简写），输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>我们就知道了网页运行在 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 上，我们在浏览器中输入该地址便能进入我们创建的博客网页啦。</p>
<p><img src="https://raw.githubusercontent.com/TommyMerlin/Image-Hosting/master/blog1-7.jpg" width="85%"></p>
<hr>
<h1 id="美化博客页面"><a href="#美化博客页面" class="headerlink" title="美化博客页面"></a>美化博客页面</h1><h2 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h2><p>可以看到打开的博客页面就是 Hexo 默认的页面，所以并不是非常得好看，我们可以自行选择更换，在 GitHub 上搜索 Hexo 主题还是有非常多的项目的。我在这里选择了目前使用人数比较多的 Next 主题进行演示。Next 主题的 Github 地址是 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">theme-next/hexotheme-next</a>。回到我们存放博客文件的根目录，输入如下指令，将该仓库克隆到本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> Blog</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>这样我们就将 Next 主题克隆到 themes/next 文件夹下啦。</p>
<h2 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h2><p>使用编辑器打开根目录下的 <code>_config.yml</code> 文件，这个文件保存的就是 Hexo 的诸多配置项，我们可以对其进行个性化修改。在文件中找到 <code>theme</code> 配置选项，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br></pre></td></tr></table></figure>
<p>可以看到现在的主题是默认的 <code>landscape</code> ，我们将其改为 <code>next</code> 即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
<p>再在 Git Bash 中依次输入下面三条指令（发布三连），<strong>请注意所有的 hexo 指令都是在根目录下进行的，如果当前目录不是根目录，必须先切换到根目录再执行命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean   <span class="comment">#清除之前生成的网站文件</span></span><br><span class="line">$ hexo g       <span class="comment">#生成当前网站文件</span></span><br><span class="line">$ hexo s       <span class="comment">#开启服务器</span></span><br></pre></td></tr></table></figure>
<p>再次打开 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> ，我们就能看到更换主题后的网站了，非常便捷。</p>
<p><img src="https://raw.githubusercontent.com/TommyMerlin/Image-Hosting/master/blog1-8.jpg" width="85%/"></p>
<p>这就是我们新生成的页面了，是不是看上去精致多了呢。</p>
<hr>
<h1 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h1><p>在完成了上述步骤之后，我们就可以在自己的电脑上打开博客网页了，但是怎么才能让别人也能访问到我们的网页呢？这就需要我们部署我们的博客网站了。幸运的是，GitHub 能为我们免费提供这一服务，那就是 GitHub Page ，我们需要做的就是在 GitHub 上新建一个名为 <code>&lt;username&gt;.github.io</code> (在<code>&lt;username&gt;</code>处填入你的用户名） 的仓库即可。</p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>打开根目录下的 <code>_config.yml</code> 文件，找到 <code>deploy</code> 选项，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>:</span><br></pre></td></tr></table></figure>
<p>将其修改为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>在其中的 <code>&lt;username&gt;</code> 处填入你的 GitHub 用户名即可。保存配置文件并退出。</p>
<p>接下来在 Git Bash 中输入下面三条指令（部署三连）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>至此，我们就已经完成了个人博客网站的部署，在浏览器中输入你的地址 ：<code>&lt;username&gt;.github.io</code> ，就能看到我们的个人网站啦！</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>网站</tag>
        <tag>windows</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/uncategorized/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
